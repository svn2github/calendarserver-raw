Index: twisted/web2/dav/method/report_principal_property_search.py
===================================================================
--- twisted/web2/dav/method/report_principal_property_search.py	(revision 19773)
+++ twisted/web2/dav/method/report_principal_property_search.py	(working copy)
@@ -51,12 +51,18 @@
         raise ValueError("%s expected as root element, not %s."
                          % (davxml.PrincipalPropertySearch.sname(), principal_property_search.sname()))
 
+    # Should we AND (the default) or OR (if test="anyof")?
+    testMode = principal_property_search.attributes.get("test", "allof")
+    if testMode not in ("allof", "anyof"):
+        raise ValueError("Unknown value for test attribute: %s" % (testMode,))
+    operand = "and" if testMode == "allof" else "or"
+
     # Only handle Depth: 0
     depth = request.headers.getHeader("depth", "0")
     if depth != "0":
         log.err("Error in prinicpal-property-search REPORT, Depth set to %s" % (depth,))
         raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, "Depth %s not allowed" % (depth,)))
-    
+
     # Get a single DAV:prop element from the REPORT request body
     propertiesForResource = None
     propElement = None
@@ -71,10 +77,22 @@
         elif child.qname() == (dav_namespace, "property-search"):
             props = child.childOfType(davxml.PropertyContainer)
             props.removeWhitespaceNodes()
+
             match = child.childOfType(davxml.Match)
-            propertySearches.append((props.children, str(match).lower()))
+            caseless = match.attributes.get("caseless", "yes")
+            if caseless not in ("yes", "no"):
+                raise ValueError("Unknown value for caseless attribute: %s" %
+                    (caseless,))
+            caseless = True if caseless == "yes" else False
+            matchType = match.attributes.get("match-type", "contains")
+            if matchType not in ("starts-with", "contains"):
+                raise ValueError("Unknown value for match-type attribute: %s" %
+                    (matchType,))
+
+            propertySearches.append((props.children, str(match),
+                caseless, matchType))
     
-    def nodeMatch(node, match):
+    def nodeMatch(node, match, caseless, matchType):
         """
         See if the content of the supplied node matches the supplied text.
         Try to follow the matching guidance in rfc3744 section 9.4.1.
@@ -85,81 +103,174 @@
         node.removeWhitespaceNodes()
         for child in node.children:
             if isinstance(child, davxml.PCDATAElement):
-                comp = str(child).lower()
-                if comp.find(match) != -1:
+                if caseless:
+                    comp = str(child).lower()
+                    match = match.lower()
+                else:
+                    comp = str(child)
+
+                if matchType == "starts-with":
+                    if comp.find(match) == 0:
+                        return True
+                elif comp.find(match) != -1:
                     return True
+
             else:
                 return nodeMatch(child, match)
         else:
             return False
         
-    def propertySearch(resource, request):
+    def propertySearch(resource, request, operand):
         """
         Test the resource to see if it contains properties matching the
         property-search specification in this report.
         @param resource: the L{DAVFile} for the resource to test.
         @param request:  the current request.
+        @param operand:  "and" or "or"
         @return:         True if the resource has matching properties, False otherwise.
         """
-        for props, match in propertySearches:
-            # Test each property
-            for prop in props:
-                try:
-                    propvalue = waitForDeferred(resource.readProperty(prop.qname(), request))
-                    yield propvalue
-                    propvalue = propvalue.getResult()
-                    if propvalue and not nodeMatch(propvalue, match):
+
+        if operand == "and":
+            for props, match, caseless, matchType in propertySearches:
+                # Test each property
+                for prop in props:
+                    try:
+                        propvalue = waitForDeferred(resource.readProperty(prop.qname(), request))
+                        yield propvalue
+                        propvalue = propvalue.getResult()
+                        if propvalue:
+                            if not nodeMatch(propvalue, match, caseless,
+                                matchType):
+                                yield False
+                                return
+                    except HTTPError:
+                        # No property => no match
                         yield False
                         return
-                except HTTPError:
-                    # No property => no match
-                    yield False
-                    return
-        
-        yield True
+            # we hit on every property
+            yield True
 
+        else: # "or"
+            for props, match, caseless, matchType in propertySearches:
+                # Test each property
+                for prop in props:
+                    try:
+                        propvalue = waitForDeferred(resource.readProperty(prop.qname(), request))
+                        yield propvalue
+                        propvalue = propvalue.getResult()
+                        if propvalue:
+                            if nodeMatch(propvalue, match, caseless, matchType):
+                                yield True
+                                return
+                    except HTTPError:
+                        # No property
+                        pass
+            # we didn't hit any
+            yield False
+
     propertySearch = deferredGenerator(propertySearch)
 
+
     # Run report
     try:
-        resources = []
-        responses = []
+
+        # See if we can take advantage of the directory
+        fields = []
+        nonDirectorySearches = []
+        for props, match, caseless, matchType in propertySearches:
+            nonDirectoryProps = []
+            for prop in props:
+                try:
+                    fieldName = self.propertyToField(prop)
+                except AttributeError:
+                    fieldName = None
+                if fieldName:
+                    fields.append((fieldName, match, caseless, matchType))
+                else:
+                    nonDirectoryProps.append(prop)
+            if nonDirectoryProps:
+                nonDirectorySearches.append((nonDirectoryProps, match,
+                    caseless, matchType))
+
+        matchingResources = []
         matchcount = 0
 
-        if applyTo:
-            # Get the principal collection set
-            pset = waitForDeferred(self.principalCollections(request))
-            yield pset
-            pset = pset.getResult()
+        if (
+            (operand == "or" and nonDirectorySearches) or
+            (operand == "and" and nonDirectorySearches and not fields)
+        ):
+            # These are the situations in which we need to iterate all the
+            # resources
+            resources = []
 
-            for phref in pset:
-                uri = str(phref)
-                resource = waitForDeferred(request.locateResource(uri))
-                yield resource
-                resource = resource.getResult()
-                if resource:
-                    resources.append((resource, uri))
-        else:
-            resources.append((self, request.uri))
+            if applyTo:
+                for principalCollection in self.principalCollections():
+                    uri = principalCollection.principalCollectionURL()
+                    resource = waitForDeferred(request.locateResource(uri))
+                    yield resource
+                    resource = resource.getResult()
+                    if resource:
+                        resources.append((resource, uri))
+            else:
+                resources.append((self, request.uri))
 
-        # Loop over all collections and principal resources within
-        for resource, ruri in resources:
+            # Loop over all collections and principal resources within
+            for resource, ruri in resources:
 
-            # Do some optimisation of access control calculation by determining any inherited ACLs outside of
-            # the child resource loop and supply those to the checkPrivileges on each child.
-            filteredaces = waitForDeferred(resource.inheritedACEsforChildren(request))
-            yield filteredaces
-            filteredaces = filteredaces.getResult()
+                # Do some optimisation of access control calculation by determining any inherited ACLs outside of
+                # the child resource loop and supply those to the checkPrivileges on each child.
+                filteredaces = waitForDeferred(resource.inheritedACEsforChildren(request))
+                yield filteredaces
+                filteredaces = filteredaces.getResult()
 
-            children = []
-            d = waitForDeferred(resource.findChildren("infinity", request, lambda x, y: children.append((x,y)),
-                                                      privileges=(davxml.Read(),), inherited_aces=filteredaces))
-            yield d
-            d.getResult()
+                children = []
+                d = waitForDeferred(resource.findChildren("infinity", request,
+                    lambda x, y: children.append((x,y)),
+                    privileges=(davxml.Read(),), inherited_aces=filteredaces))
+                yield d
+                d.getResult()
 
-            for child, uri in children:
-                if isPrincipalResource(child):
-                    d = waitForDeferred(propertySearch(child, request))
+                for child, uri in children:
+                    if isPrincipalResource(child):
+                        d = waitForDeferred(propertySearch(child, request,
+                            operand))
+                        yield d
+                        d = d.getResult()
+                        if d:
+                            # Check size of results is within limit
+                            matchcount += 1
+                            if matchcount > max_number_of_matches:
+                                raise NumberOfMatchesWithinLimits
+
+                            matchingResources.append(child)
+
+
+        elif fields: # search the directory
+            try:
+                recordType = self.recordType
+            except AttributeError:
+                recordType = None
+
+            for record in self.directory.recordsMatchingFields(fields,
+                operand=operand, recordType=recordType):
+
+                resource = self.principalForRecord(record)
+                url = resource.url()
+
+                if not nonDirectorySearches:
+                    # We've determined this is a matching resource
+
+                    matchcount += 1
+                    if matchcount > max_number_of_matches:
+                        raise NumberOfMatchesWithinLimits
+                    matchingResources.append(resource)
+
+                elif operand == "and":
+                    # Further narrowing down needs to take place by examining
+                    # the resource's DAV properties
+
+                    d = waitForDeferred(propertySearch(resource, request,
+                        operand))
                     yield d
                     d = d.getResult()
                     if d:
@@ -167,18 +278,26 @@
                         matchcount += 1
                         if matchcount > max_number_of_matches:
                             raise NumberOfMatchesWithinLimits
-    
-                        d = waitForDeferred(prop_common.responseForHref(
-                            request,
-                            responses,
-                            davxml.HRef.fromString(uri),
-                            child,
-                            propertiesForResource,
-                            propElement
-                        ))
-                        yield d
-                        d.getResult()
+                        matchingResources.append(resource)
 
+
+
+        # Generate the response
+        responses = []
+        for resource in matchingResources:
+            url = resource.url()
+            d = waitForDeferred(prop_common.responseForHref(
+                request,
+                responses,
+                davxml.HRef.fromString(url),
+                resource,
+                propertiesForResource,
+                propElement
+            ))
+            yield d
+            d.getResult()
+
+
     except NumberOfMatchesWithinLimits:
         log.err("Too many matching components in prinicpal-property-search report")
         raise HTTPError(ErrorResponse(
