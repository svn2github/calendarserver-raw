=== modified file 'twisted/web2/dav/resource.py'
--- twisted/web2/dav/resource.py	2009-05-07 20:35:07 +0000
+++ twisted/web2/dav/resource.py	2009-07-15 23:30:18 +0000
@@ -49,12 +49,14 @@
 if not hasattr(__builtin__, "frozenset"):
     import sets.ImmutableSet as frozenset
 
+import urllib
+
 from zope.interface import implements
+from twisted.cred.error import LoginFailed, UnauthorizedLogin
 from twisted.python import log
 from twisted.python.failure import Failure
-from twisted.internet.defer import Deferred, maybeDeferred, succeed
+from twisted.internet.defer import Deferred, maybeDeferred, succeed, inlineCallbacks
 from twisted.internet.defer import waitForDeferred, deferredGenerator
-from twisted.cred.error import LoginFailed, UnauthorizedLogin
 from twisted.internet import reactor
 from twisted.web2 import responsecode
 from twisted.web2.http import HTTPError, RedirectResponse, StatusResponse
@@ -578,7 +580,6 @@
 
         completionDeferred = Deferred()
         basepath = request.urlForResource(self)
-        children = list(self.listChildren())
 
         def checkPrivilegesError(failure):
             failure.trap(AccessDeniedError)
@@ -595,7 +596,7 @@
             d.addCallback(lambda _: child)
             return d
 
-        def gotChild(child, childpath):
+        def gotChild(child, childpath, children):
             if child is None:
                 callback(None, childpath + "/")
             else:
@@ -603,14 +604,15 @@
                     callback(child, childpath + "/")
                     if depth == "infinity":
                         d = child.findChildren(depth, request, callback, privileges)
-                        d.addCallback(lambda x: reactor.callLater(0, getChild))
+                        d.addCallback(lambda x: reactor.callLater(0, getChild, children))
                         return d
                 else:
                     callback(child, childpath)
 
-            reactor.callLater(0, getChild)
+            reactor.callLater(0, getChild, children)
 
-        def getChild():
+        def getChild(children):
+            children = list(children)
             try:
                 childname = children.pop()
             except IndexError:
@@ -619,10 +621,10 @@
                 childpath = joinURL(basepath, childname)
                 d = request.locateChildResource(self, childname)
                 d.addCallback(checkPrivileges)
-                d.addCallbacks(gotChild, checkPrivilegesError, (childpath,))
+                d.addCallbacks(gotChild, checkPrivilegesError, (childpath, children))
                 d.addErrback(completionDeferred.errback)
 
-        getChild()
+        self.listChildren().addCallback(getChild)
 
         return completionDeferred
 
@@ -642,39 +644,41 @@
     # Authentication
     ##
 
+    @inlineCallbacks
     def authorize(self, request, privileges, recurse=False):
         """
         See L{IDAVResource.authorize}.
         """
-        def onAuth(result):
-            def onErrors(failure):
-                failure.trap(AccessDeniedError)
-                
-                # If we were unauthorized to start with (no Authorization header from client) then
-                # we should return an unauthorized response instead to force the client to login if it can
-                if request.authnUser == davxml.Principal(davxml.Unauthenticated()):
-                    d = UnauthorizedResponse.makeResponse(request.credentialFactories,
-                                                                 request.remoteAddr)
-                    def _fail(response):
-                        return Failure(HTTPError(response))
-                    return d.addCallback(_fail)
-                else:
-                    response = NeedPrivilegesResponse(request.uri,
-                                                      failure.value.errors)
-                #
-                # We're not adding the headers here because this response
-                # class is supposed to be a FORBIDDEN status code and
-                # "Authorization will not help" according to RFC2616
-                #
-                raise HTTPError(response)
-
-            d = self.checkPrivileges(request, privileges, recurse)
-            d.addErrback(onErrors)
-            return d
-
-        d = maybeDeferred(self.authenticate, request)
-        d.addCallback(onAuth)
-        return d
+
+        try:
+            yield self.authenticate(request)
+        except (UnauthorizedLogin, LoginFailed), e:
+            log.msg("Authentication failed: %s" % (e,))
+            response = (yield UnauthorizedResponse.makeResponse(
+                request.credentialFactories,
+                request.remoteAddr
+            ))
+            raise HTTPError(response)
+
+        try:
+            yield self.checkPrivileges(request, privileges, recurse)
+        except AccessDeniedError, e:
+            # If we were unauthenticated to start with (no Authorization header from client) then
+            # we should return an unauthorized response instead to force the client to login if it can
+            if request.authnUser == davxml.Principal(davxml.Unauthenticated()):
+                response = (yield UnauthorizedResponse.makeResponse(
+                    request.credentialFactories,
+                    request.remoteAddr
+                ))
+            else:
+                response = NeedPrivilegesResponse(request.uri, e.errors)
+            #
+            # We're not adding the headers here because this response
+            # class is supposed to be a FORBIDDEN status code and
+            # "Authorization will not help" according to RFC2616
+            #
+            raise HTTPError(response)
+
 
 
     def authenticate(self, request):
@@ -1880,7 +1884,7 @@
         # If this is a collection and the URI doesn't end in "/", redirect.
         #
         if self.isCollection() and request.path[-1:] != "/":
-            return RedirectResponse(request.unparseURL(path=request.path+'/'))
+            return RedirectResponse(request.unparseURL(path=urllib.quote(urllib.unquote(request.path), safe=':/')+'/'))
 
         def setHeaders(response):
             response = IResponse(response)

