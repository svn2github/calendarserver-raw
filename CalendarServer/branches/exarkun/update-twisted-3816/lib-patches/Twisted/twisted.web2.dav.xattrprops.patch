Index: twisted/web2/dav/xattrprops.py
===================================================================
--- twisted/web2/dav/xattrprops.py	(revision 26389)
+++ twisted/web2/dav/xattrprops.py	(working copy)
@@ -34,21 +34,27 @@
 import urllib
 import sys
 import zlib
+
+from operator import setitem
 from time import sleep
 from random import random
 from errno import EAGAIN
 from zlib import compress, decompress
+from cPickle import UnpicklingError, loads as unpickle
 
 import xattr
 
 if getattr(xattr, 'xattr', None) is None:
     raise ImportError("wrong xattr package imported")
 
+from twisted.python.util import untilConcludes
 from twisted.python import log
 from twisted.web2 import responsecode
 from twisted.web2.http import HTTPError, StatusResponse
 from twisted.web2.dav import davxml
+from twisted.web2.dav.http import statusForFailure
 
+
 class xattrPropertyStore (object):
     """
 
@@ -94,59 +100,109 @@
         self.attrs = xattr.xattr(self.resource.fp.path)
 
     def get(self, qname):
+        """
+        Retrieve the value of a property stored as an extended attribute on the
+        wrapped path.
+
+        @param qname: The property to retrieve as a two-tuple of namespace URI
+            and local name.
+
+        @raise HTTPError: If there is no value associated with the given
+            property.
+
+        @return: A L{WebDAVDocument} representing the value associated with the
+            given property.
+        """
         try:
             data = self.attrs[self._encode(qname)]
-            try:
-                value = decompress(data)
-            except zlib.error:
-                # Value is not compressed; data was stored by old
-                # code.  This is easy to handle, so let's keep
-                # compatibility here.
-                value = data
-            del data
         except KeyError:
             raise HTTPError(StatusResponse(
                 responsecode.NOT_FOUND,
                 "No such property: {%s}%s" % qname
             ))
+        except:
+            # XXX Untested, I can't get the getitem to actually fail in a test
+            # environment. -exarkun
+            raise HTTPError(
+                StatusResponse(
+                    statusForFailure(Failure()),
+                    "Unable to read property: " + key))
 
+        #
+        # Unserialize XML data from an xattr.  The storage format has changed
+        # over time:
+        #
+        #  1- Started with XML
+        #  2- Started compressing the XML due to limits on xattr size
+        #  3- Switched to pickle which is faster, still compressing
+        #  4- Back to compressed XML for interoperability, size
+        #
+        # We only write the current format, but we also read the old
+        # ones for compatibility.
+        #
+        legacy = False
+
         try:
-            doc = davxml.WebDAVDocument.fromString(value)
+            data = decompress(data)
+        except zlib.error:
+            legacy = True
 
-            return doc.root_element
+        try:
+            doc = davxml.WebDAVDocument.fromString(data)
         except ValueError:
-            msg = "Invalid property value stored on server: {%s}%s %s" % (qname[0], qname[1], value)
-            log.err(msg)
-            raise HTTPError(StatusResponse(responsecode.INTERNAL_SERVER_ERROR, msg))
-
-    def set(self, property):
-        for n in range(20):
             try:
-                self.attrs[self._encode(property.qname())] = compress(property.toxml())
-            except IOError, error:
-                if error.errno != EAGAIN:
-                    raise
-                sleep(random() / 10) # OMG Brutal Hax
+                doc = unpickle(data)
+            except UnpicklingError:
+                format = "Invalid property value stored on server: {%s}%s %s"
+                msg = format % (qname[0], qname[1], data)
+                log.err(None, msg)
+                raise HTTPError(
+                    StatusResponse(responsecode.INTERNAL_SERVER_ERROR, msg))
             else:
-                break
-    
+                legacy = True
 
+        if legacy:
+            self.set(doc.root_element)
+
+        return doc.root_element
+
+
+    def set(self, property):
+        key = self._encode(property.qname())
+        value = compress(property.toxml())
+        untilConcludes(setitem, self.attrs, key, value)
+
         # Update the resource because we've modified it
         self.resource.fp.restat()
 
     def delete(self, qname):
+        key = self._encode(qname)
         try:
-            del(self.attrs[self._encode(qname)])
-        except KeyError:
+            del self.attrs[key]
+        except KeyError, e:
             # RFC 2518 Section 12.13.1 says that removal of
             # non-existing property is not an error.
             pass
+        except:
+            # XXX Untested, I can't get the delitem to actually fail in a test
+            # environment. -exarkun
+            raise HTTPError(
+                StatusResponse(
+                    statusForFailure(Failure()),
+                    "Unable to delete property: " + key))
 
     def contains(self, qname):
         try:
             return self._encode(qname) in self.attrs
         except TypeError:
             return False
+        except:
+            # XXX Untested, I can't get the __contains__ to actually fail in a
+            # test environment. -exarkun
+            raise HTTPError(
+                StatusResponse(
+                    statusForFailure(Failure()),
+                    "Unable to read property: " + key))
 
     def list(self):
         prefix     = self.deadPropertyXattrPrefix
