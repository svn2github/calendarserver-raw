Index: src/vobject/base.py
===================================================================
--- src/vobject/base.py	(revision 164)
+++ src/vobject/base.py	(working copy)
@@ -842,14 +842,36 @@
     return param
 
 def foldOneLine(outbuf, input, lineLength = 75):
-    if isinstance(input, basestring): input = StringIO.StringIO(input)
-    input.seek(0)
-    outbuf.write(input.read(lineLength) + CRLF)
-    brokenline = input.read(lineLength - 1)
-    while brokenline:
-        outbuf.write(' ' + brokenline + CRLF)
-        brokenline = input.read(lineLength - 1)
+    # Folding line procedure that ensures multi-byte utf-8 sequences are not broken
+    # across lines
 
+    if len(input) < lineLength:
+        # Optimize for unfolded line case
+        outbuf.write(input)
+    else:
+        # Look for valid utf8 range and write that out
+        start = 0
+        written = 0
+        while written < len(input):
+            # Start max length -1 chars on from where we are
+            offset = start + lineLength - 1
+            if offset >= len(input):
+                line = input[start:]
+                outbuf.write(line)
+                written = len(input)
+            else:
+                # Check whether next char is valid utf8 lead byte
+                while (input[offset] > 0x7F) and ((ord(input[offset]) & 0xC0) == 0x80):
+                    # Step back until we have a valid char
+                    offset -= 1
+                
+                line = input[start:offset]
+                outbuf.write(line)
+                outbuf.write("\r\n ")
+                written += offset - start
+                start = offset
+    outbuf.write("\r\n")
+
 def defaultSerialize(obj, buf, lineLength):
     """Encode and fold obj and its children, write to buf or return a string."""
 
@@ -861,12 +883,12 @@
         else:
             groupString = obj.group + '.'
         if obj.useBegin:
-            foldOneLine(outbuf, groupString + u"BEGIN:" + obj.name, lineLength)
+            foldOneLine(outbuf, str(groupString + u"BEGIN:" + obj.name), lineLength)
         for child in obj.getSortedChildren():
             #validate is recursive, we only need to validate once
             child.serialize(outbuf, lineLength, validate=False)
         if obj.useBegin:
-            foldOneLine(outbuf, groupString + u"END:" + obj.name, lineLength)
+            foldOneLine(outbuf, str(groupString + u"END:" + obj.name), lineLength)
         if DEBUG: logger.debug("Finished %s" % obj.name.upper())
         
     elif isinstance(obj, ContentLine):
@@ -875,14 +897,18 @@
         if obj.behavior and not startedEncoded: obj.behavior.encode(obj)
         s=StringIO.StringIO() #unfolded buffer
         if obj.group is not None:
-            s.write(obj.group + '.')
+            s.write(str(obj.group + '.'))
         if DEBUG: logger.debug("Serializing line" + str(obj))
-        s.write(obj.name.upper())
+        s.write(str(obj.name.upper()))
         for key, paramvals in obj.params.iteritems():
-            s.write(';' + key + '=' + ','.join(map(dquoteEscape, paramvals)))
-        s.write(':' + obj.value)
+            s.write(';' + str(key) + '=' + ','.join(map(dquoteEscape, paramvals)).encode("utf-8"))
+        if isinstance(obj.value, unicode):
+            strout = obj.value.encode("utf-8")
+        else:
+            strout = obj.value
+        s.write(':' + strout)
         if obj.behavior and not startedEncoded: obj.behavior.decode(obj)
-        foldOneLine(outbuf, s, lineLength)
+        foldOneLine(outbuf, s.getvalue(), lineLength)
         if DEBUG: logger.debug("Finished %s line" % obj.name.upper())
     
     return buf or outbuf.getvalue()
@@ -1023,7 +1049,7 @@
     else:
         obj = ContentLine(name, [], '')
     obj.behavior = behavior
-    obj.isNative = True
+    obj.isNative = False
     return obj
 
 
