Index: twisted/web2/auth/digest.py
===================================================================
--- twisted/web2/auth/digest.py	(revision 19737)
+++ twisted/web2/auth/digest.py	(working copy)
@@ -5,9 +5,10 @@
 
 http://www.faqs.org/rfcs/rfc2617.html
 """
+import time
 
 from twisted.cred import credentials, error
-from zope.interface import implements
+from zope.interface import implements, Interface
 
 from twisted.web2.auth.interfaces import ICredentialFactory
 
@@ -17,9 +18,9 @@
 # The digest math
 
 algorithms = {
-    'md5': md5.md5,
-    'md5-sess': md5.md5,
-    'sha': sha.sha,
+    'md5': md5.new,
+    'md5-sess': md5.new,
+    'sha': sha.new,
 }
 
 # DigestCalcHA1
@@ -30,15 +31,40 @@
     pszPassword,
     pszNonce,
     pszCNonce,
+    preHA1=None
 ):
+    """
+    @param pszAlg: The name of the algorithm to use to calculate the digest.
+        Currently supported are md5 md5-sess and sha.
 
-    m = algorithms[pszAlg]()
-    m.update(pszUserName)
-    m.update(":")
-    m.update(pszRealm)
-    m.update(":")
-    m.update(pszPassword)
-    HA1 = m.digest()
+    @param pszUserName: The username
+    @param pszRealm: The realm
+    @param pszPassword: The password
+    @param pszNonce: The nonce
+    @param pszCNonce: The cnonce
+
+    @param preHA1: If available this is a str containing a previously
+       calculated HA1 as a hex string. If this is given then the values for
+       pszUserName, pszRealm, and pszPassword are ignored.
+    """
+
+    if (preHA1 and (pszUserName or pszRealm or pszPassword)):
+        raise TypeError(("preHA1 is incompatible with the pszUserName, "
+                         "pszRealm, and pszPassword arguments"))
+
+    if not preHA1:
+        # We need to calculate the HA1 from the username:realm:password
+        m = algorithms[pszAlg]()
+        m.update(pszUserName)
+        m.update(":")
+        m.update(pszRealm)
+        m.update(":")
+        m.update(pszPassword)
+        HA1 = m.digest()
+    else:
+        # We were given a username:realm:password
+        HA1 = preHA1.decode('hex')
+
     if pszAlg == "md5-sess":
         m = algorithms[pszAlg]()
         m.update(HA1)
@@ -47,6 +73,7 @@
         m.update(":")
         m.update(pszCNonce)
         HA1 = m.digest()
+
     return HA1.encode('hex')
 
 # DigestCalcResponse
@@ -83,14 +110,29 @@
         m.update(pszQop)
         m.update(":")
     m.update(HA2)
-    hash = m.digest().encode('hex')
-    return hash
+    respHash = m.digest().encode('hex')
+    return respHash
 
 
+class IUsernameDigestHash(Interface):
+    """
+    This credential is used when a CredentialChecker has access to the hash
+    of the username:realm:password as in an Apache .htdigest file.
+    """
+    def checkHash(self, digestHash):
+        """
+        @param digestHash: The hashed username:realm:password to check against.
+
+        @return: a deferred which becomes, or a boolean indicating if the
+            hash matches.
+        """
+
+
 class DigestedCredentials:
     """Yet Another Simple HTTP Digest authentication scheme"""
 
-    implements(credentials.IUsernameHashedPassword)
+    implements(credentials.IUsernameHashedPassword,
+               IUsernameDigestHash)
 
     def __init__(self, username, method, realm, fields):
         self.username = username
@@ -114,40 +156,143 @@
 
         return expected == response
 
+    def checkHash(self, digestHash):
+        response = self.fields.get('response')
+        uri = self.fields.get('uri')
+        nonce = self.fields.get('nonce')
+        cnonce = self.fields.get('cnonce')
+        nc = self.fields.get('nc')
+        algo = self.fields.get('algorithm', 'md5').lower()
+        qop = self.fields.get('qop', 'auth')
 
-class DigestCredentialFactory:
+        expected = calcResponse(
+            calcHA1(algo, None, None, None, nonce, cnonce, preHA1=digestHash),
+            algo, nonce, nc, cnonce, qop, self.method, uri, None
+        )
+
+        return expected == response
+
+
+class DigestCredentialFactory(object):
+    """
+    Support for RFC2617 HTTP Digest Authentication
+
+    @cvar CHALLENGE_LIFETIME_SECS: The number of seconds for which an
+        opaque should be valid.
+
+    @ivar privateKey: A random string used for generating the secure opaque.
+    """
+
     implements(ICredentialFactory)
 
-    CHALLENGE_LIFETIME = 15
+    CHALLENGE_LIFETIME_SECS = 15 * 60    # 15 minutes
 
     scheme = "digest"
 
     def __init__(self, algorithm, realm):
-        """@type algorithm: C{str}
-           @param algorithm: case insensitive string that specifies
-              the hash algorithm used, should be either, md5, md5-sess
-              or sha
+        """
+        @type algorithm: C{str}
+        @param algorithm: case insensitive string that specifies
+            the hash algorithm used, should be either, md5, md5-sess
+            or sha
 
-           @type realm: C{str}
-           @param realm: case sensitive string that specifies the realm
-                         portion of the challenge
+        @type realm: C{str}
+        @param realm: case sensitive string that specifies the realm
+            portion of the challenge
         """
-        self.outstanding = {}
         self.algorithm = algorithm
         self.realm = realm
 
+        c = tuple([random.randrange(sys.maxint) for _ in range(3)])
+
+        self.privateKey = '%d%d%d' % c
+
     def generateNonce(self):
         c = tuple([random.randrange(sys.maxint) for _ in range(3)])
         c = '%d%d%d' % c
         return c
 
-    def generateOpaque(self):
-        return str(random.randrange(sys.maxint))
+    def _getTime(self):
+        """
+        Parameterize the time based seed used in generateOpaque
+        so we can deterministically unittest it's behavior.
+        """
+        return time.time()
 
+    def generateOpaque(self, nonce, clientip):
+        """
+        Generate an opaque to be returned to the client.
+        This should be a unique string that can be returned to us and verified.
+        """
+
+        # Now, what we do is encode the nonce, client ip and a timestamp
+        # in the opaque value with a suitable digest
+        key = "%s,%s,%s" % (nonce, clientip, str(int(self._getTime())))
+        digest = md5.new(key + self.privateKey).hexdigest()
+        ekey = key.encode('base64')
+        return "%s-%s" % (digest, ekey.strip('\n'))
+
+    def verifyOpaque(self, opaque, nonce, clientip):
+        """
+        Given the opaque and nonce from the request, as well as the clientip
+        that made the request, verify that the opaque was generated by us.
+        And that it's not too old."
+
+        @param opaque: The opaque value from the Digest response
+        @param nonce: The nonce value from the Digest response
+        @param clientip: The remote IP address of the client making the request
+
+        @return: Return True if the opaque was successfully verified
+
+        @raise L{twisted.cred.error.LoginFailed}
+        """
+
+        # First split the digest from the key
+        opaque_parts = opaque.split('-')
+        if len(opaque_parts) != 2:
+            raise error.LoginFailed('Invalid response, invalid opaque value')
+
+        # Verify the key
+        key = opaque_parts[1].decode('base64')
+        key_parts = key.split(',')
+
+        if len(key_parts) != 3:
+            raise error.LoginFailed('Invalid response, invalid opaque value')
+
+        if key_parts[0] != nonce:
+            raise error.LoginFailed(
+                'Invalid response, incompatible opaque/nonce values')
+
+        if key_parts[1] != clientip:
+            raise error.LoginFailed(
+                'Invalid response, incompatible opaque/client values')
+
+        if (int(self._getTime()) - int(key_parts[2]) >
+            DigestCredentialFactory.CHALLENGE_LIFETIME_SECS):
+
+            raise error.LoginFailed(
+                'Invalid response, incompatible opaque/nonce too old')
+
+        # Verify the digest
+        digest = md5.new(key + self.privateKey).hexdigest()
+        if digest != opaque_parts[0]:
+            raise error.LoginFailed('Invalid response, invalid opaque value')
+
+        return True
+
     def getChallenge(self, peer):
+        """
+        Generate the challenge for use in the WWW-Authenticate header
+
+        @param peer: The L{IAddress} of the requesting client.
+
+        @return: The C{dict} that can be used to generate a WWW-Authenticate
+            header.
+        """
+
         c = self.generateNonce()
-        o = self.generateOpaque()
-        self.outstanding[o] = c
+        o = self.generateOpaque(c, peer.host)
+
         return {'nonce': c,
                 'opaque': o,
                 'qop': 'auth',
@@ -161,15 +306,22 @@
             return s
         response = ' '.join(response.splitlines())
         parts = response.split(',')
-        auth = dict([(k.strip(), unq(v.strip())) for (k, v) in [p.split('=', 1) for p in parts]])
 
+        auth = {}
+
+        for (k, v) in [p.split('=', 1) for p in parts]:
+            auth[k.strip()] = unq(v.strip())
+
         username = auth.get('username')
         if not username:
             raise error.LoginFailed('Invalid response, no username given')
 
-        if auth.get('opaque') not in self.outstanding:
-            raise error.LoginFailed('Invalid response, opaque not outstanding')
+        # Now verify the nonce/opaque values for this client
+        if self.verifyOpaque(auth.get('opaque'),
+                             auth.get('nonce'),
+                             request.remoteAddr.host):
 
-        del self.outstanding[auth['opaque']]
-
-        return DigestedCredentials(username, request.method, self.realm, auth)
+            return DigestedCredentials(username,
+                                       request.method,
+                                       self.realm,
+                                       auth)
