Index: twisted/web2/dav/resource.py
===================================================================
--- twisted/web2/dav/resource.py	(revision 17967)
+++ twisted/web2/dav/resource.py	(working copy)
@@ -593,9 +593,6 @@
                 factory = request.credentialFactories[authHeader[0]]
 
                 creds = factory.decode(authHeader[1], request.method)
-                
-
-                creds = factory.decode(authHeader[1], request.method)
 
                 # Try to match principals in each principal collection on 
                 # the resource
@@ -635,7 +632,7 @@
         @return: the current principal, as derived from the given request.
         """
         if hasattr(request, "user"):
-            return request.user.element
+            return request.user
         else:
             return unauthenticatedPrincipal
 
@@ -760,7 +757,10 @@
                 elif isinstance(item, davxml.SupportedPrivilege):
                     addSupportedPrivilege(item)
 
-        for item in self.supportedPrivileges(request).children:
+        supportedPrivs = waitForDeferred(self.supportedPrivileges(request))
+        yield supportedPrivs
+        supportedPrivs = supportedPrivs.getResult()
+        for item in supportedPrivs.children:
             assert (
                 isinstance(item, davxml.SupportedPrivilege),
                 "Not a SupportedPrivilege: %r" % (item,)
@@ -920,11 +920,16 @@
         yield ign
         ign.getResult()
 
-        for resource, subpath in resources:
-            acl = waitForDeferred(resource.accessControlList(request))
+        for resource, uri in resources:
+            acl = waitForDeferred(resource.accessControlList(request, inheritedaces=inheritedaces))
             yield acl
             acl = acl.getResult()
 
+            # Check for disabled
+            if acl is None:
+                errors.append((uri, list(privileges)))
+                continue
+
             pending = list(privileges)
             denied = []
 
@@ -930,7 +935,7 @@
 
             for ace in acl.children:
                 for privilege in tuple(pending):
-                    if not match_privilege(privilege, ace.privileges):
+                    if not match_privilege(davxml.Privilege(privilege), ace.privileges):
                         continue
 
                     match = waitForDeferred(self.matchPrincipal(principal, ace.principal, request))
@@ -952,7 +957,7 @@
             denied += pending # If no matching ACE, then denied
 
             if denied: 
-                errors.append((subpath, denied))
+                errors.append((uri, denied))
 
         if errors:
             raise AccessDeniedError(errors,)
@@ -1015,6 +1020,7 @@
         disabled = self.hasDeadProperty(TwistedAccessDisabledProperty)
         if disabled:
             yield None
+            return
 
         myURL = None
 
@@ -1069,6 +1075,7 @@
                         # Check disabled
                         if parent_acl is None:
                             yield None
+                            return
     
                         for ace in parent_acl.children:
                             if ace.inherited:
@@ -1100,7 +1107,6 @@
 
     accessControlList = deferredGenerator(accessControlList)
 
-    # TODO: Convert to deferredGenerator
     def inheritedACEsforChildren(self, request):
         """
         Do some optimisation of access control calculation by determining any inherited ACLs outside of
@@ -1112,11 +1118,14 @@
         """
         
         # Get the parent ACLs with inheritance and preserve the <inheritable> element.
-        parent_acl = self.accessControlList(request, inheritance=True, expanding=True)
+        parent_acl = waitForDeferred(self.accessControlList(request, inheritance=True, expanding=True))
+        yield parent_acl
+        parent_acl = parent_acl.getResult()
         
         # Check disabled
         if parent_acl is None:
-            return None
+            yield None
+            return
 
         # Filter out those that are not inheritable (and remove the inheritable element from those that are)
         aces = []
@@ -1141,7 +1150,9 @@
                 if not ace.invert:
                     continue
             filteredaces.append(ace)
-        return filteredaces
+        yield filteredaces
+
+    inheritedACEsforChildren = deferredGenerator(inheritedACEsforChildren)
 
     def inheritedACLSet(self):
         """
@@ -1180,6 +1191,14 @@
                 yield (principal, principalURI)
                 return
         else:
+            principalCollections = waitForDeferred(self.principalCollections(request))
+            yield principalCollections
+            principalCollections = principalCollections.getResult()
+
+            if len(principalCollections) == 0:
+                log.msg("<DAV:principal-collection-set> property cannot be found on the resource being authorized: %s" % self)
+            else:
+                log.msg("Could not find principal matching user id: %s" % authid)
             raise HTTPError(responsecode.FORBIDDEN)
 
     findPrincipalForAuthID = deferredGenerator(findPrincipalForAuthID)
@@ -1261,7 +1280,7 @@
         assert principal2 is not None, "principal2 is None"
 
 
-         # Compare two HRefs and do group membership test as well
+        # Compare two HRefs and do group membership test as well
         if principal1 == principal2:
             yield True
             return
@@ -1301,7 +1320,7 @@
         d = request.locateResource(principal2)
         d.addCallback(_testGroup)
         return d
-
+        
     def validPrincipal(self, ace_principal, request):
         """
         Check whether the supplied principal is valid for this resource.
@@ -1317,16 +1336,16 @@
             # We know that the element contains a valid element type, so all
             # we need to do is check for a valid property and a valid href.
             #
-            ace_principal = ace_principal.children[0]
+            real_principal = ace_principal.children[0]
 
-            if isinstance(ace_principal, davxml.Property):
+            if isinstance(real_principal, davxml.Property):
                 # See comments in matchPrincipal().  We probably need some common code.
                 log.err("Encountered a property principal (%s), but handling is not implemented.  Invalid for ACL use."
-                        % (ace_principal,))
+                        % (real_principal,))
                 return False
 
-            if isinstance(ace_principal, davxml.HRef):
-                return self.validHrefPrincipal(ace_principal, request)
+            if isinstance(real_principal, davxml.HRef):
+                return self.validHrefPrincipal(real_principal, request)
 
             return True
 
@@ -1367,7 +1386,6 @@
         @param request: the request being processed.
         @return: a deferred L{davxml.HRef} element or C{None}.
         """
-        principal = principal.children[0]
 
         if isinstance(principal, davxml.Property):
             # raise NotImplementedError("Property principals are not implemented.")
@@ -1428,15 +1446,6 @@
         if isinstance(principal, davxml.HRef):
             yield principal
         else:
-            principalCollections = waitForDeferred(
-                self.principalCollections(request))
-            yield principalCollections
-            principalCollections = principalCollections.getResult()
-
-            if len(principalCollections) == 0:
-                log.msg("<DAV:principal-collection-set> property cannot be found on the resource being authorized: %s" % self)
-            else:
-                log.msg("Could not find principal matching user id: %s" % authid)
             yield None
 
         assert (
