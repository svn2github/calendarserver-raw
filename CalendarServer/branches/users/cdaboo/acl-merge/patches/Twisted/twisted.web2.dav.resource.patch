Index: twisted/web2/dav/resource.py
===================================================================
--- twisted/web2/dav/resource.py	(revision 17967)
+++ twisted/web2/dav/resource.py	(working copy)
@@ -593,9 +593,6 @@
                 factory = request.credentialFactories[authHeader[0]]
 
                 creds = factory.decode(authHeader[1], request.method)
-                
-
-                creds = factory.decode(authHeader[1], request.method)
 
                 # Try to match principals in each principal collection on 
                 # the resource
@@ -635,7 +632,7 @@
         @return: the current principal, as derived from the given request.
         """
         if hasattr(request, "user"):
-            return request.user.element
+            return request.user
         else:
             return unauthenticatedPrincipal
 
@@ -760,7 +757,10 @@
                 elif isinstance(item, davxml.SupportedPrivilege):
                     addSupportedPrivilege(item)
 
-        for item in self.supportedPrivileges(request).children:
+        supportedPrivs = waitForDeferred(self.supportedPrivileges(request))
+        yield supportedPrivs
+        supportedPrivs = supportedPrivs.getResult()
+        for item in supportedPrivs.children:
             assert (
                 isinstance(item, davxml.SupportedPrivilege),
                 "Not a SupportedPrivilege: %r" % (item,)
@@ -920,7 +920,7 @@
         yield ign
         ign.getResult()
 
-        for resource, subpath in resources:
+        for resource, uri in resources:
             acl = waitForDeferred(resource.accessControlList(request))
             yield acl
             acl = acl.getResult()
@@ -930,7 +930,7 @@
 
             for ace in acl.children:
                 for privilege in tuple(pending):
-                    if not match_privilege(privilege, ace.privileges):
+                    if not match_privilege(davxml.Privilege(privilege), ace.privileges):
                         continue
 
                     match = waitForDeferred(self.matchPrincipal(principal, ace.principal, request))
@@ -952,7 +952,7 @@
             denied += pending # If no matching ACE, then denied
 
             if denied: 
-                errors.append((subpath, denied))
+                errors.append((uri, denied))
 
         if errors:
             raise AccessDeniedError(errors,)
@@ -1180,6 +1180,14 @@
                 yield (principal, principalURI)
                 return
         else:
+            principalCollections = waitForDeferred(self.principalCollections(request))
+            yield principalCollections
+            principalCollections = principalCollections.getResult()
+
+            if len(principalCollections) == 0:
+                log.msg("<DAV:principal-collection-set> property cannot be found on the resource being authorized: %s" % self)
+            else:
+                log.msg("Could not find principal matching user id: %s" % authid)
             raise HTTPError(responsecode.FORBIDDEN)
 
     findPrincipalForAuthID = deferredGenerator(findPrincipalForAuthID)
@@ -1261,7 +1269,7 @@
         assert principal2 is not None, "principal2 is None"
 
 
-         # Compare two HRefs and do group membership test as well
+        # Compare two HRefs and do group membership test as well
         if principal1 == principal2:
             yield True
             return
@@ -1301,7 +1309,7 @@
         d = request.locateResource(principal2)
         d.addCallback(_testGroup)
         return d
-
+        
     def validPrincipal(self, ace_principal, request):
         """
         Check whether the supplied principal is valid for this resource.
@@ -1317,16 +1325,16 @@
             # We know that the element contains a valid element type, so all
             # we need to do is check for a valid property and a valid href.
             #
-            ace_principal = ace_principal.children[0]
+            real_principal = ace_principal.children[0]
 
-            if isinstance(ace_principal, davxml.Property):
+            if isinstance(real_principal, davxml.Property):
                 # See comments in matchPrincipal().  We probably need some common code.
                 log.err("Encountered a property principal (%s), but handling is not implemented.  Invalid for ACL use."
-                        % (ace_principal,))
+                        % (real_principal,))
                 return False
 
-            if isinstance(ace_principal, davxml.HRef):
-                return self.validHrefPrincipal(ace_principal, request)
+            if isinstance(real_principal, davxml.HRef):
+                return self.validHrefPrincipal(real_principal, request)
 
             return True
 
@@ -1367,7 +1375,6 @@
         @param request: the request being processed.
         @return: a deferred L{davxml.HRef} element or C{None}.
         """
-        principal = principal.children[0]
 
         if isinstance(principal, davxml.Property):
             # raise NotImplementedError("Property principals are not implemented.")
@@ -1428,15 +1435,6 @@
         if isinstance(principal, davxml.HRef):
             yield principal
         else:
-            principalCollections = waitForDeferred(
-                self.principalCollections(request))
-            yield principalCollections
-            principalCollections = principalCollections.getResult()
-
-            if len(principalCollections) == 0:
-                log.msg("<DAV:principal-collection-set> property cannot be found on the resource being authorized: %s" % self)
-            else:
-                log.msg("Could not find principal matching user id: %s" % authid)
             yield None
 
         assert (
