Index: twisted/web2/dav/resource.py
===================================================================
--- twisted/web2/dav/resource.py	(revision 19773)
+++ twisted/web2/dav/resource.py	(working copy)
@@ -31,20 +31,30 @@
     "DAVResource",
     "DAVLeafResource",
     "DAVPrincipalResource",
+    "DAVPrincipalCollectionResource",
     "AccessDeniedError",
     "isPrincipalResource",
     "TwistedACLInheritable",
+    "TwistedGETContentMD5",
+    "TwistedQuotaRootProperty",
     "allACL",
     "readonlyACL",
     "davPrivilegeSet",
     "unauthenticatedPrincipal",
 ]
 
-import urllib
+import __builtin__
+if not hasattr(__builtin__, "set"):
+    import sets.Set as set
+if not hasattr(__builtin__, "frozenset"):
+    import sets.ImmutableSet as frozenset
 
 from zope.interface import implements
 from twisted.python import log
-from twisted.internet.defer import Deferred, maybeDeferred, succeed
+from twisted.python.failure import Failure
+from twisted.cred.error import LoginFailed, UnauthorizedLogin
+from twisted.internet.defer import Deferred, maybeDeferred, succeed,\
+    inlineCallbacks, returnValue
 from twisted.internet.defer import waitForDeferred, deferredGenerator
 from twisted.internet import reactor
 from twisted.web2 import responsecode
@@ -52,12 +62,13 @@
 from twisted.web2.http_headers import generateContentType
 from twisted.web2.iweb import IResponse
 from twisted.web2.resource import LeafResource
+from twisted.web2.server import NoURLForResourceError
 from twisted.web2.static import MetaDataMixin, StaticRenderMixin
 from twisted.web2.auth.wrapper import UnauthorizedResponse
 from twisted.web2.dav import davxml
 from twisted.web2.dav.davxml import dav_namespace, lookupElement
 from twisted.web2.dav.davxml import twisted_dav_namespace, twisted_private_namespace
-from twisted.web2.dav.idav import IDAVResource, IDAVPrincipalResource
+from twisted.web2.dav.idav import IDAVResource, IDAVPrincipalResource, IDAVPrincipalCollectionResource
 from twisted.web2.dav.http import NeedPrivilegesResponse
 from twisted.web2.dav.noneprops import NonePropertyStore
 from twisted.web2.dav.util import unimplemented, parentForURL, joinURL
@@ -126,10 +137,13 @@
        #(dav_namespace, "group"                     ), # RFC 3744, section 5.2
         (dav_namespace, "supported-privilege-set"   ), # RFC 3744, section 5.3
         (dav_namespace, "current-user-privilege-set"), # RFC 3744, section 5.4
+        (dav_namespace, "current-user-principal"    ), # draft-sanchez-webdav-current-principal
         (dav_namespace, "acl"                       ), # RFC 3744, section 5.5
         (dav_namespace, "acl-restrictions"          ), # RFC 3744, section 5.6
         (dav_namespace, "inherited-acl-set"         ), # RFC 3744, section 5.7
         (dav_namespace, "principal-collection-set"  ), # RFC 3744, section 5.8
+        (dav_namespace, "quota-available-bytes"     ), # RFC 4331, section 3
+        (dav_namespace, "quota-used-bytes"          ), # RFC 4331, section 4
 
         (twisted_dav_namespace, "resource-class"),
     )
@@ -166,6 +180,14 @@
         if qname[0] == twisted_private_namespace:
             return succeed(False)
 
+        # Need to special case the dynamic live properties
+        namespace, name = qname
+        if namespace == dav_namespace:
+            if name in ("quota-available-bytes", "quota-used-bytes"):
+                d = self.hasQuota(request)
+                d.addCallback(lambda result: result)
+                return d
+        
         return succeed(qname in self.liveProperties or self.deadProperties().contains(qname))
 
     def readProperty(self, property, request):
@@ -201,7 +223,6 @@
                     mimeType = self.contentType()
                     if mimeType is None:
                         return None
-                    mimeType.params = None # WebDAV getcontenttype property does not include parameters
                     return davxml.GETContentType(generateContentType(mimeType))
 
                 if name == "getcontentlength":
@@ -239,8 +260,10 @@
                     )
 
                 if name == "supported-report-set":
-                    supported = [davxml.SupportedReport(report,) for report in self.supportedReports()]
-                    return davxml.SupportedReportSet(*supported)
+                    return davxml.SupportedReportSet(*[
+                        davxml.SupportedReport(report,)
+                        for report in self.supportedReports()
+                    ])
 
                 if name == "supported-privilege-set":
                     return self.supportedPrivileges(request)
@@ -252,9 +275,10 @@
                     return davxml.InheritedACLSet(*self.inheritedACLSet())
 
                 if name == "principal-collection-set":
-                    d = self.principalCollections(request)
-                    d.addCallback(lambda collections: davxml.PrincipalCollectionSet(*collections))
-                    return d
+                    return davxml.PrincipalCollectionSet(*[
+                        davxml.HRef(principalCollection.principalCollectionURL())
+                        for principalCollection in self.principalCollections()
+                    ])
 
                 def ifAllowed(privileges, callback):
                     def onError(failure):
@@ -286,7 +310,36 @@
                         d.addCallback(gotACL)
                         return d
                     return ifAllowed((davxml.ReadACL(),), callback)
+                
+                if name == "current-user-principal":
+                    return davxml.CurrentUserPrincipal(self.currentPrincipal(request).children[0])
 
+                if name == "quota-available-bytes":
+                    def callback(qvalue):
+                        if qvalue is None:
+                            raise HTTPError(StatusResponse(
+                                responsecode.NOT_FOUND,
+                                "Property %s does not exist." % (sname,)
+                            ))
+                        else:
+                            return davxml.QuotaAvailableBytes(str(qvalue[0]))
+                    d = self.quota(request)
+                    d.addCallback(callback)
+                    return d
+
+                if name == "quota-used-bytes":
+                    def callback(qvalue):
+                        if qvalue is None:
+                            raise HTTPError(StatusResponse(
+                                responsecode.NOT_FOUND,
+                                "Property %s does not exist." % (sname,)
+                            ))
+                        else:
+                            return davxml.QuotaUsedBytes(str(qvalue[1]))
+                    d = self.quota(request)
+                    d.addCallback(callback)
+                    return d
+
             elif namespace == twisted_dav_namespace:
                 if name == "resource-class":
                     class ResourceClass (davxml.WebDAVTextElement):
@@ -309,10 +362,7 @@
         """
         See L{IDAVResource.writeProperty}.
         """
-        assert (
-            isinstance(property, davxml.WebDAVElement),
-            "Not a property: %r" % (property,)
-        )
+        assert isinstance(property, davxml.WebDAVElement), "Not a property: %r" % (property,)
 
         def defer():
             if property.protected:
@@ -363,15 +413,28 @@
         """
         See L{IDAVResource.listProperties}.
         """
-        # FIXME: A set would be better here, that that's a python 2.4+ feature.
-        qnames = list(self.liveProperties)
+        qnames = set(self.liveProperties)
 
+        # Add dynamic live properties that exist
+        dynamicLiveProperties = (
+            (dav_namespace, "quota-available-bytes"     ),
+            (dav_namespace, "quota-used-bytes"          ),
+        )
+        for dqname in dynamicLiveProperties:
+            has = waitForDeferred(self.hasProperty(dqname, request))
+            yield has
+            has = has.getResult()
+            if not has:
+                qnames.remove(dqname)
+
         for qname in self.deadProperties().list():
             if (qname not in qnames) and (qname[0] != twisted_private_namespace):
-                qnames.append(qname)
+                qnames.add(qname)
 
-        return succeed(qnames)
+        yield qnames
 
+    listProperties = deferredGenerator(listProperties)
+
     def listAllprop(self, request):
         """
         Some DAV properties should not be returned to a C{DAV:allprop} query.
@@ -465,8 +528,22 @@
             return super(DAVPropertyMixIn, self).displayName()
 
 class DAVResource (DAVPropertyMixIn, StaticRenderMixin):
+    """
+    WebDAV resource.
+    """
     implements(IDAVResource)
 
+    def __init__(self, principalCollections=None):
+        """
+        @param principalCollections: an iterable of L{IDAVPrincipalCollectionResource}s
+            which contain principals to be used in ACLs for this resource.
+        """
+        if principalCollections is not None:
+            self._principalCollections = frozenset([
+                IDAVPrincipalCollectionResource(principalCollection)
+                for principalCollection in principalCollections
+            ])
+
     ##
     # DAV
     ##
@@ -553,69 +630,65 @@
     def supportedReports(self):
         """
         See L{IDAVResource.supportedReports}.
-        This implementation lists the three main ACL reports.
+        This implementation lists the three main ACL reports and expand-property.
         """
         result = []
         result.append(davxml.Report(davxml.ACLPrincipalPropSet(),))
         result.append(davxml.Report(davxml.PrincipalMatch(),))
         result.append(davxml.Report(davxml.PrincipalPropertySearch(),))
+        result.append(davxml.Report(davxml.ExpandProperty(),))
         return result
 
     ##
     # Authentication
     ##
 
+    @inlineCallbacks
     def authorize(self, request, privileges, recurse=False):
         """
         See L{IDAVResource.authorize}.
         """
-        def onError(failure):
-            log.err("Invalid authentication details: %s" % (request,))
-            raise HTTPError(UnauthorizedResponse(
+
+        try:
+            yield self.authenticate(request)
+        except (UnauthorizedLogin, LoginFailed), e:
+            log.msg("Authentication failed: %s" % (e,))
+            response = (yield UnauthorizedResponse.makeResponse(
                 request.credentialFactories,
                 request.remoteAddr
             ))
+            raise HTTPError(response)
 
-        def onAuth(result):
-            def onErrors(failure):
-                failure.trap(AccessDeniedError)
-                
-                # If we were unauthorized to start with (no Authorization header from client) then
-                # we should return an unauthorized response instead to force the client to login if it can
-                if request.user == davxml.Principal(davxml.Unauthenticated()):
-                    response = UnauthorizedResponse(request.credentialFactories,
-                                                    request.remoteAddr)
-                else:
-                    response = NeedPrivilegesResponse(request.uri,
-                                                      failure.value.errors)
-                #
-                # We're not adding the headers here because this response
-                # class is supposed to be a FORBIDDEN status code and
-                # "Authorization will not help" according to RFC2616
-                #
-                raise HTTPError(response)
+        try:
+            yield self.checkPrivileges(request, privileges, recurse)
+        except AccessDeniedError, e:
+            # If we were unauthenticated to start with (no Authorization header from client) then
+            # we should return an unauthorized response instead to force the client to login if it can
+            if request.authnUser == davxml.Principal(davxml.Unauthenticated()):
+                response = (yield UnauthorizedResponse.makeResponse(
+                    request.credentialFactories,
+                    request.remoteAddr
+                ))
+            else:
+                response = NeedPrivilegesResponse(request.uri, e.errors)
+            #
+            # We're not adding the headers here because this response
+            # class is supposed to be a FORBIDDEN status code and
+            # "Authorization will not help" according to RFC2616
+            #
+            raise HTTPError(response)
 
-            d = self.checkPrivileges(request, privileges, recurse)
-            d.addErrback(onErrors)
-            return d
-
-        d = maybeDeferred(self.authenticate, request)
-        d.addCallbacks(onAuth, onError)
-
-        return d
-
+    @inlineCallbacks
     def authenticate(self, request):
-        def loginSuccess(result):
-            request.user = result[1]
-            return request.user
 
         if not (
             hasattr(request, 'portal') and 
             hasattr(request, 'credentialFactories') and
             hasattr(request, 'loginInterfaces')
         ):
-            request.user = davxml.Principal(davxml.Unauthenticated())
-            return request.user
+            request.authnUser = davxml.Principal(davxml.Unauthenticated())
+            request.authzUser = davxml.Principal(davxml.Unauthenticated())
+            returnValue((request.authnUser, request.authzUser,))
 
         authHeader = request.headers.getHeader('authorization')
 
@@ -623,31 +696,32 @@
             if authHeader[0] not in request.credentialFactories:
                 log.err("Client authentication scheme %s is not provided by server %s"
                         % (authHeader[0], request.credentialFactories.keys()))
-                raise HTTPError(responsecode.FORBIDDEN)
+
+                response = (yield UnauthorizedResponse.makeResponse(
+                    request.credentialFactories,
+                    request.remoteAddr
+                ))
+                raise HTTPError(response)
             else:
                 factory = request.credentialFactories[authHeader[0]]
 
-                creds = factory.decode(authHeader[1], request)
+                creds = (yield factory.decode(authHeader[1], request))
 
                 # Try to match principals in each principal collection on the resource
-                def gotDetails(details):
-                    principal = IDAVPrincipalResource(details[0])
-                    principalURI = details[1]
-                    return PrincipalCredentials(principal, principalURI, creds)
+                authnPrincipal, authzPrincipal = (yield self.principalsForAuthID(request, creds.username))
+                authnPrincipal = IDAVPrincipalResource(authnPrincipal)
+                authzPrincipal = IDAVPrincipalResource(authzPrincipal)
 
-                def login(pcreds):
-                    d = request.portal.login(pcreds, None, *request.loginInterfaces)
-                    d.addCallback(loginSuccess)
+                pcreds = PrincipalCredentials(authnPrincipal, authzPrincipal, creds)
 
-                    return d
-
-                d = self.findPrincipalForAuthID(request, creds.username)
-                d.addCallback(gotDetails).addCallback(login)
-
-                return d
+                result = (yield request.portal.login(pcreds, None, *request.loginInterfaces))
+                request.authnUser = result[1]
+                request.authzUser = result[2]
+                returnValue((request.authnUser, request.authzUser,))
         else:
-            request.user = davxml.Principal(davxml.Unauthenticated())
-            return request.user
+            request.authnUser = davxml.Principal(davxml.Unauthenticated())
+            request.authzUser = davxml.Principal(davxml.Unauthenticated())
+            returnValue((request.authnUser, request.authzUser,))
 
     ##
     # ACL
@@ -656,49 +730,23 @@
     def currentPrincipal(self, request):
         """
         @param request: the request being processed.
-        @return: the current principal, as derived from the given request.
+        @return: the current authorized principal, as derived from the given request.
         """
-        if hasattr(request, "user"):
-            return request.user
+        if hasattr(request, "authzUser"):
+            return request.authzUser
         else:
             return unauthenticatedPrincipal
 
-    def principalCollections(self, request):
+    def principalCollections(self):
         """
         See L{IDAVResource.accessControlList}.
-
-        This implementation tries to read the L{davxml.PrincipalCollectionSet}
-        from the dead property store of this resource and uses that. If not
-        present on this resource, it tries to get it from the parent, unless it
-        is the root or has no parent.
         """
-        try:
-            principalCollections = self.readDeadProperty(davxml.PrincipalCollectionSet).childrenOfType(davxml.HRef)
-        except HTTPError, e:
-            if e.response.code != responsecode.NOT_FOUND:
-                raise
+        if hasattr(self, "_principalCollections"):
+            return self._principalCollections
+        else:
+            return ()
 
-            principalCollections = []
-
-            # Try the parent
-            myURL = request.urlForResource(self)
-            if myURL != "/":
-                parentURL = parentForURL(myURL)
-
-                parent = waitForDeferred(request.locateResource(parentURL))
-                yield parent
-                parent = parent.getResult()
-
-                if parent:
-                    principalCollections = waitForDeferred(parent.principalCollections(request))
-                    yield principalCollections
-                    principalCollections = principalCollections.getResult()
-
-        yield principalCollections
-
-    principalCollections = deferredGenerator(principalCollections)
-
-    def defaultAccessControlList(self):
+    def defaultRootAccessControlList(self):
         """
         @return: the L{davxml.ACL} element containing the default access control
             list for this resource.
@@ -710,6 +758,17 @@
         #
         return readonlyACL
 
+    def defaultAccessControlList(self):
+        """
+        @return: the L{davxml.ACL} element containing the default access control
+            list for this resource.
+        """
+        #
+        # The default behaviour is no ACL; we should inherrit from the parent
+        # collection.
+        #
+        return davxml.ACL()
+
     def setAccessControlList(self, acl):
         """
         See L{IDAVResource.setAccessControlList}.
@@ -748,13 +807,16 @@
         # 10. Verify that new acl is not in conflict with itself
         # 11. Update acl on the resource
 
-        old_acl = waitForDeferred(self.accessControlList(request))
+        # Get the current access control list, preserving any private properties on the ACEs as
+        # we will need to keep those when we change the ACL.
+        old_acl = waitForDeferred(self.accessControlList(request, expanding=True))
         yield old_acl
         old_acl = old_acl.getResult()
 
         # Check disabled
         if old_acl is None:
             yield None
+            return
 
         # Need to get list of supported privileges
         supported = []
@@ -773,10 +835,7 @@
         yield supportedPrivs
         supportedPrivs = supportedPrivs.getResult()
         for item in supportedPrivs.children:
-            assert (
-                isinstance(item, davxml.SupportedPrivilege),
-                "Not a SupportedPrivilege: %r" % (item,)
-            )
+            assert isinstance(item, davxml.SupportedPrivilege), "Not a SupportedPrivilege: %r" % (item,)
             addSupportedPrivilege(item)
 
         # Steps 1 - 6
@@ -910,8 +969,7 @@
         supportedPrivs = supportedPrivs.getResult()
 
         # Other principals types don't make sense as actors.
-        assert (
-            principal.children[0].name in ("unauthenticated", "href"),
+        assert principal.children[0].name in ("unauthenticated", "href"), (
             "Principal is not an actor: %r" % (principal,)
         )
 
@@ -1019,15 +1077,16 @@
         def getMyURL():
             url = request.urlForResource(self)
 
-            assert url is not None, "urlForResource(self) returned None for resource %s" % (self,)
+            assert url is not None, (
+                "urlForResource(self) returned None for resource %s" % (self,)
+            )
 
             return url
 
         try:
             acl = self.readDeadProperty(davxml.ACL)
         except HTTPError, e:
-            assert (
-                e.response.code == responsecode.NOT_FOUND,
+            assert e.response.code == responsecode.NOT_FOUND, (
                 "Expected %s response from readDeadProperty() exception, not %s"
                 % (responsecode.NOT_FOUND, e.response.code)
             )
@@ -1038,9 +1097,9 @@
 
             if myURL == "/":
                 # If we get to the root without any ACLs, then use the default.
+                acl = self.defaultRootAccessControlList()
+            else:
                 acl = self.defaultAccessControlList()
-            else:
-                acl = davxml.ACL()
 
         # Dynamically update privileges for those ace's that are inherited.
         if inheritance:
@@ -1076,7 +1135,7 @@
                                 # Adjust ACE for inherit on this resource
                                 children = list(ace.children)
                                 children.remove(TwistedACLInheritable())
-                                children.append(davxml.Inherited(davxml.HRef.fromString(parentURL)))
+                                children.append(davxml.Inherited(davxml.HRef(parentURL)))
                                 aces.append(davxml.ACE(*children))
             else:
                 aces.extend(inherited_aces)
@@ -1105,8 +1164,7 @@
         the child resource loop and supply those to the checkPrivileges on each child.
 
         @param request: the L{IRequest} for the request in progress.
-        @return:        a C{list} of L{Ace}s that child resources of this one will
-            inherit and which will match the currently authenticated principal.
+        @return:        a C{list} of L{Ace}s that child resources of this one will inherit.
         """
         
         # Get the parent ACLs with inheritance and preserve the <inheritable> element.
@@ -1128,21 +1186,9 @@
                 # Adjust ACE for inherit on this resource
                 children = list(ace.children)
                 children.remove(TwistedACLInheritable())
-                children.append(davxml.Inherited(davxml.HRef.fromString(request.urlForResource(self))))
+                children.append(davxml.Inherited(davxml.HRef(request.urlForResource(self))))
                 aces.append(davxml.ACE(*children))
-                
-        # Filter out those that do not have a principal match with the current principal
-        principal = self.currentPrincipal(request)
-        filteredaces = []
-        for ace in aces:
-            if self.matchPrincipal(principal, ace.principal, request):
-                if ace.invert:
-                    continue
-            else:
-                if not ace.invert:
-                    continue
-            filteredaces.append(ace)
-        yield filteredaces
+        yield aces
 
     inheritedACEsforChildren = deferredGenerator(inheritedACEsforChildren)
 
@@ -1152,49 +1198,69 @@
 
         This implementation returns an empty set.
         """
-
         return []
 
-    def findPrincipalForAuthID(self, request, authid):
+    def principalsForAuthID(self, request, authid):
         """
+        Return authentication and authorization prinicipal identifiers for the
+        authentication identifer passed in. In this implementation authn and authz
+        principals are the same.
+
         @param request: the L{IRequest} for the request in progress.
         @param authid: a string containing the
             authentication/authorization identifier for the principal
             to lookup.
-        @return: a deferred tuple of C{(principal, principalURI)}
-            where: C{principal} is the L{Principal} that is found;
-            C{principalURI} is the C{str} URI of the principal. 
+        @return: a deferred tuple of two tuples. Each tuple is
+            C{(principal, principalURI)} where: C{principal} is the L{Principal}
+            that is found; {principalURI} is the C{str} URI of the principal.
+            The first tuple corresponds to authentication identifiers,
+            the second to authorization identifiers.
             It will errback with an HTTPError(responsecode.FORBIDDEN) if
             the principal isn't found.
         """
-        # Try to match principals in each principal collection on the resource
-        collections = waitForDeferred(self.principalCollections(request))
-        yield collections
-        collections = collections.getResult()
+        authnPrincipal = self.findPrincipalForAuthID(authid)
 
-        for collection in collections:
-            principalURI = joinURL(str(collection), authid)
+        if authnPrincipal is None:
+            log.msg("Could not find the principal resource for user id: %s" % (authid,))
+            raise HTTPError(responsecode.FORBIDDEN)
 
-            principal = waitForDeferred(request.locateResource(principalURI))
-            yield principal
-            principal = principal.getResult()
+        d = self.authorizationPrincipal(request, authid, authnPrincipal)
+        d.addCallback(lambda authzPrincipal: (authnPrincipal, authzPrincipal))
+        return d
 
-            if isPrincipalResource(principal):
-                yield (principal, principalURI)
-                return
-        else:
-            principalCollections = waitForDeferred(self.principalCollections(request))
-            yield principalCollections
-            principalCollections = principalCollections.getResult()
+    def findPrincipalForAuthID(self, authid):
+        """
+        Return authentication and authoirization prinicipal identifiers for the
+        authentication identifer passed in. In this implementation authn and authz
+        principals are the same.
 
-            if len(principalCollections) == 0:
-                log.msg("DAV:principal-collection-set property cannot be found on the resource being authorized: %s" % self)
-            else:
-                log.msg("Could not find principal matching user id: %s" % authid)
-            raise HTTPError(responsecode.FORBIDDEN)
+        @param authid: a string containing the
+            authentication/authorization identifier for the principal
+            to lookup.
+        @return: a tuple of C{(principal, principalURI)} where: C{principal} is the L{Principal}
+            that is found; {principalURI} is the C{str} URI of the principal.
+            If not found return None.
+        """
+        for collection in self.principalCollections():
+            principal = collection.principalForUser(authid)
+            if principal is not None:
+                return principal
+        return None
 
-    findPrincipalForAuthID = deferredGenerator(findPrincipalForAuthID)
-
+    def authorizationPrincipal(self, request, authid, authnPrincipal):
+        """
+        Determine the authorization principal for the given request and authentication principal.
+        This implementation simply uses aht authentication principalk as the authoization principal.
+        
+        @param request: the L{IRequest} for the request in progress.
+        @param authid: a string containing the uthentication/authorization identifier
+            for the principal to lookup.
+        @param authnPrincipal: the L{IDAVPrincipal} for the authenticated principal
+         @return: a deferred result C{tuple} of (L{IDAVPrincipal}, C{str}) containing the authorization principal
+            resource and URI respectively.
+        """
+        return succeed(authnPrincipal)
+        
     def samePrincipal(self, principal1, principal2):
         """
         Check whether the two prinicpals are exactly the same in terms of
@@ -1219,7 +1285,6 @@
             return False
                 
     def matchPrincipal(self, principal1, principal2, request):
-
         """
         Check whether the principal1 is a principal in the set defined by
         principal2.
@@ -1244,6 +1309,9 @@
             if isinstance(principal1, davxml.Unauthenticated):
                 yield False
                 return
+            elif isinstance(principal1, davxml.All):
+                yield False
+                return
             else:
                 yield True
                 return
@@ -1260,10 +1328,7 @@
             yield False
             return
 
-        assert (
-            isinstance(principal1, davxml.HRef),
-            "Not an HRef: %r" % (principal1,)
-        )
+        assert isinstance(principal1, davxml.HRef), "Not an HRef: %r" % (principal1,)
 
         principal2 = waitForDeferred(self.resolvePrincipal(principal2, request))
         yield principal2
@@ -1271,7 +1336,6 @@
 
         assert principal2 is not None, "principal2 is None"
 
-
         # Compare two HRefs and do group membership test as well
         if principal1 == principal2:
             yield True
@@ -1289,6 +1353,7 @@
 
     matchPrincipal = deferredGenerator(matchPrincipal)
 
+    @deferredGenerator
     def principalIsGroupMember(self, principal1, principal2, request):
         """
         Check whether one principal is a group member of another.
@@ -1299,18 +1364,21 @@
         @return: L{Deferred} with result C{True} if principal1 is a member of principal2, C{False} otherwise
         """
         
-        def testGroup(group):
-            # Get principal resource for principal2
-            if group and isinstance(group, DAVPrincipalResource):
-                members = group.groupMembers()
-                if principal1 in members:
-                    return True
-                
-            return False
+        d = waitForDeferred(request.locateResource(principal2))
+        yield d
+        group = d.getResult()
 
-        d = request.locateResource(principal2)
-        d.addCallback(testGroup)
-        return d
+        # Get principal resource for principal2
+        if group and isinstance(group, DAVPrincipalResource):
+            d = waitForDeferred(group.expandedGroupMembers())
+            yield d
+            members = d.getResult()
+            for member in members:
+                if member.principalURL() == principal1:
+                    yield True
+                    return
+            
+        yield False
         
     def validPrincipal(self, ace_principal, request):
         """
@@ -1351,11 +1419,16 @@
         @return C{True} if C{href_principal} is valid, C{False} otherwise.
 
         This implementation tests for a href element that corresponds to
-        a principal resource.
+        a principal resource and matches the principal-URL.
         """
-        # Must have the principal resource type
+
+        # Must have the principal resource type and must match the principal-URL
+        
+        def _matchPrincipalURL(resource):
+            return isPrincipalResource(resource) and resource.principalURL() == str(href_principal)
+
         d = request.locateResource(str(href_principal))
-        d.addCallback(isPrincipalResource)
+        d.addCallback(_matchPrincipalURL)
         return d
 
     def resolvePrincipal(self, principal, request):
@@ -1404,8 +1477,7 @@
             try:
                 principal = principal.getResult()
             except HTTPError, e:
-                assert (
-                    e.response.code == responsecode.NOT_FOUND,
+                assert e.response.code == responsecode.NOT_FOUND, (
                     "Expected %s response from readProperty() exception, not %s"
                     % (responsecode.NOT_FOUND, e.response.code)
                 )
@@ -1432,15 +1504,15 @@
                 log.err("DAV:self ACE is set on non-principal resource %r" % (self,))
                 yield None
                 return
-            principal = davxml.HRef.fromString(self.principalURL())
+            principal = davxml.HRef(self.principalURL())
 
         if isinstance(principal, davxml.HRef):
             yield principal
+            return
         else:
             yield None
 
-        assert (
-            isinstance(principal, (davxml.All, davxml.Authenticated, davxml.Unauthenticated)),
+        assert isinstance(principal, (davxml.All, davxml.Authenticated, davxml.Unauthenticated)), (
             "Not a meta-principal: %r" % (principal,)
         )
 
@@ -1517,6 +1589,270 @@
         return None
 
     ##
+    # Quota
+    ##
+    
+    """
+    The basic policy here is to define a private 'quota-root' property on a collection.
+    That property will contain the maximum allowed bytes for the collections and all
+    its contents.
+    
+    In order to determine the quota property values on a resource, the server must look
+    for the private property on that resource and any of its parents. If found on a parent,
+    then that parent should be queried for quota information. If not found, no quota
+    exists for the resource.
+    
+    To determine tha actual quota in use we will cache the used byte count on the quota-root
+    collection in another private property. It is the servers responsibility to
+    keep that property up to date by adjusting it after every PUT, DELETE, COPY,
+    MOVE, MKCOL, PROPPATCH, ACL, POST or any other method that may affect the size of
+    stored data. If the private property is not present, the server will fall back to
+    getting the size by iterating over all resources (this is done in static.py).
+    
+    """
+
+    def quota(self, request):
+        """
+        Get current available & used quota values for this resource's quota root
+        collection.
+
+        @return: an L{Defered} with result C{tuple} containing two C{int}'s the first is 
+            quota-available-bytes, the second is quota-used-bytes, or
+            C{None} if quota is not defined on the resource.
+        """
+        
+        # See if already cached
+        if not hasattr(request, "quota"):
+            request.quota = {}
+        if request.quota.has_key(self):
+            yield request.quota[self]
+            return
+
+        # Check this resource first
+        if self.isCollection():
+            qroot = self.quotaRoot(request)
+            if qroot is not None:
+                used = waitForDeferred(self.currentQuotaUse(request))
+                yield used
+                used = used.getResult()
+                available = qroot - used
+                if available < 0:
+                    available = 0
+                request.quota[self] = (available, used)
+                yield request.quota[self]
+                return
+        
+        # Check the next parent
+        url = request.urlForResource(self)
+        if url != "/":
+            parent = waitForDeferred(request.locateResource(parentForURL(url)))
+            yield parent
+            parent = parent.getResult()
+            d = waitForDeferred(parent.quota(request))
+            yield d
+            request.quota[self] = d.getResult()
+        else:
+            request.quota[self] = None
+
+        yield request.quota[self]
+        return
+    
+    quota = deferredGenerator(quota)
+
+    def hasQuota(self, request):
+        """
+        Check whether this resource is undre quota control by checking each parent to see if
+        it has a quota root.
+        
+        @return: C{True} if under quota control, C{False} if not.
+        """
+        
+        # Check this one first
+        if self.hasQuotaRoot(request):
+            yield True
+            return
+        
+        # Look at each parent
+        try:
+            url = request.urlForResource(self)
+            if url != "/":
+                parent = waitForDeferred(request.locateResource(parentForURL(url)))
+                yield parent
+                parent = parent.getResult()
+                d = waitForDeferred(parent.hasQuota(request))
+                yield d
+                yield d.getResult()
+            else:
+                yield False
+        except NoURLForResourceError:
+            yield False
+    
+    hasQuota = deferredGenerator(hasQuota)
+        
+    def hasQuotaRoot(self, request):
+        """
+        @return: a C{True} if this resource has quota root, C{False} otherwise.
+        """
+        return self.hasDeadProperty(TwistedQuotaRootProperty)
+    
+    def quotaRoot(self, request):
+        """
+        @return: a C{int} containing the maximum allowed bytes if this collection
+            is quota-controlled, or C{None} if not quota controlled.
+        """
+        if self.hasDeadProperty(TwistedQuotaRootProperty):
+            return int(str(self.readDeadProperty(TwistedQuotaRootProperty)))
+        else:
+            return None
+    
+    def quotaRootParent(self, request):
+        """
+        Return the next quota root above this resource.
+        
+        @return: L{DAVResource} or C{None}
+        """
+
+        # Check the next parent
+        url = request.urlForResource(self)
+        while (url != "/"):
+            url = parentForURL(url)
+            parent = waitForDeferred(request.locateResource(url))
+            yield parent
+            parent = parent.getResult()
+            if parent.hasQuotaRoot(request):
+                yield parent
+                return
+
+        yield None
+    
+    quotaRootParent = deferredGenerator(quotaRootParent)
+        
+    def setQuotaRoot(self, request, maxsize):
+        """
+        @param maxsize: a C{int} containing the maximum allowed bytes for the contents
+            of this collection, or C{None} tp remove quota restriction.
+        """
+        assert self.isCollection(), "Only collections can have a quota root"
+        assert maxsize is None or isinstance(maxsize, int), "maxsize must be an int or None"
+        
+        if maxsize is not None:
+            self.writeDeadProperty(TwistedQuotaRootProperty(str(maxsize)))
+        else:
+            # Remove both the root and the cached used value
+            self.removeDeadProperty(TwistedQuotaRootProperty)
+            self.removeDeadProperty(TwistedQuotaUsedProperty)
+    
+    def quotaSize(self, request):
+        """
+        Get the size of this resource (if its a collection get total for all children as well).
+        TODO: Take into account size of dead-properties.
+
+        @return: a C{int} containing the size of the resource.
+        """
+        unimplemented(self)
+
+    def checkQuota(self, request, available):
+        """
+        Check to see whether all quota roots have sufficient available bytes.
+        We currently do not use hierarchical quota checks - i.e. only the most
+        immediate quota root parent is checked for quota.
+        
+        @param available: a C{int} containing the additional quota required.
+        @return: C{True} if there is sufficient quota remaining on all quota roots,
+            C{False} otherwise.
+        """
+        
+        quotaroot = self
+        while(quotaroot is not None):
+            # Check quota on this root (if it has one)
+            quota = quotaroot.quotaRoot(request)
+            if quota is not None:
+                if available > quota[0]:
+                    yield False
+                    return
+
+            # Check the next parent with a quota root
+            quotaroot = waitForDeferred(quotaroot.quotaRootParent(request))
+            yield quotaroot
+            quotaroot = quotaroot.getResult()
+
+        yield True
+
+    checkQuota = deferredGenerator(checkQuota)
+
+    def quotaSizeAdjust(self, request, adjust):
+        """
+        Update the quota used value on all quota root parents of this resource.
+
+        @param adjust: a C{int} containing the number of bytes added (positive) or
+            removed (negative) that should be used to adjust the cached total.
+        """
+        
+        # Check this resource first
+        if self.isCollection():
+            if self.hasQuotaRoot(request):
+                d = waitForDeferred(self.updateQuotaUse(request, adjust))
+                yield d
+                d.getResult()
+        
+        # Check the next parent
+        url = request.urlForResource(self)
+        if url != "/":
+            parent = waitForDeferred(request.locateResource(parentForURL(url)))
+            yield parent
+            parent = parent.getResult()
+            d = waitForDeferred(parent.quotaSizeAdjust(request, adjust))
+            yield d
+            d.getResult()
+
+        yield None
+
+    quotaSizeAdjust = deferredGenerator(quotaSizeAdjust)
+
+    def currentQuotaUse(self, request):
+        """
+        Get the cached quota use value, or if not present (or invalid) determine
+        quota use by brute force.
+
+        @return: an L{Deferred} with a C{int} result containing the current used byte if this collection
+            is quota-controlled, or C{None} if not quota controlled.
+        """
+        assert self.isCollection(), "Only collections can have a quota root"
+        assert self.hasQuotaRoot(request), "Quota use only on quota root collection"
+        
+        # Try to get the cached value property
+        if self.hasDeadProperty(TwistedQuotaUsedProperty):
+            return succeed(int(str(self.readDeadProperty(TwistedQuotaUsedProperty))))
+        else:
+            # Do brute force size determination and cache the result in the private property
+            def _defer(result):
+                self.writeDeadProperty(TwistedQuotaUsedProperty(str(result)))
+                return result
+            d = self.quotaSize(request)
+            d.addCallback(_defer)
+            return d
+
+    def updateQuotaUse(self, request, adjust):
+        """
+        Update the quota used value on this resource.
+
+        @param adjust: a C{int} containing the number of bytes added (positive) or
+        removed (negative) that should be used to adjust the cached total.
+        @return: an L{Deferred} with a C{int} result containing the current used byte if this collection
+            is quota-controlled, or C{None} if not quota controlled.
+        """
+        assert self.isCollection(), "Only collections can have a quota root"
+        
+        # Get current value
+        def _defer(size):
+            size += adjust
+            self.writeDeadProperty(TwistedQuotaUsedProperty(str(size)))
+
+        d = self.currentQuotaUse(request)
+        d.addCallback(_defer)
+        return d
+        
+    ##
     # HTTP
     ##
 
@@ -1525,15 +1861,11 @@
         #litmus = request.headers.getRawHeaders("x-litmus")
         #if litmus: log.msg("*** Litmus test: %s ***" % (litmus,))
 
-        # FIXME: Learn how to use twisted logging facility, wsanchez
-        protocol = "HTTP/%s.%s" % request.clientproto
-        log.msg("%s %s %s" % (request.method, urllib.unquote(request.uri), protocol))
-
         #
         # If this is a collection and the URI doesn't end in "/", redirect.
         #
-        if self.isCollection() and request.uri[-1:] != "/":
-            return RedirectResponse(request.uri + "/")
+        if self.isCollection() and request.path[-1:] != "/":
+            return RedirectResponse(request.unparseURL(path=request.path+'/'))
 
         def setHeaders(response):
             response = IResponse(response)
@@ -1567,7 +1899,7 @@
     def findChildren(self, depth, request, callback, privileges=None, inherited_aces=None):
         return succeed(None)
 
-class DAVPrincipalResource (DAVLeafResource):
+class DAVPrincipalResource (DAVResource):
     """
     Resource representing a WebDAV principal.  (RFC 3744, section 2)
     """
@@ -1577,7 +1909,7 @@
     # WebDAV
     ##
 
-    liveProperties = DAVLeafResource.liveProperties + (
+    liveProperties = DAVResource.liveProperties + (
         (dav_namespace, "alternate-URI-set"),
         (dav_namespace, "principal-URL"    ),
         (dav_namespace, "group-member-set" ),
@@ -1585,14 +1917,11 @@
     )
 
     def davComplianceClasses(self):
-        return ("1",)
+        return ("1", "access-control",)
 
     def isCollection(self):
         return False
 
-    def findChildren(self, depth, request, callback, privileges=None, inherited_aces=None):
-        return succeed(None)
-
     def readProperty(self, property, request):
         def defer():
             if type(property) is tuple:
@@ -1610,10 +1939,20 @@
                     return davxml.PrincipalURL(davxml.HRef(self.principalURL()))
 
                 if name == "group-member-set":
-                    return davxml.GroupMemberSet(*[davxml.HRef(p) for p in self.groupMembers()])
+                    def callback(members):
+                        return davxml.GroupMemberSet(*[davxml.HRef(p.principalURL()) for p in members])
+                    
+                    d = self.groupMembers()
+                    d.addCallback(callback)
+                    return d
 
                 if name == "group-membership":
-                    return davxml.GroupMembership(*[davxml.HRef(g) for g in self.groupMemberships()])
+                    def callback(memberships):
+                        return davxml.GroupMembership(*[davxml.HRef(g.principalURL()) for g in memberships])
+                    
+                    d = self.groupMemberships()
+                    d.addCallback(callback)
+                    return d
 
                 if name == "resourcetype":
                     if self.isCollection():
@@ -1655,7 +1994,7 @@
         principals.  Subclasses should override this method to provide member
         URLs for this resource if appropriate.
         """
-        return ()
+        return succeed(())
 
     def groupMemberships(self):
         """
@@ -1666,6 +2005,7 @@
         """
         unimplemented(self)
 
+    @deferredGenerator
     def principalMatch(self, href):
         """
         Check whether the supplied principal matches this principal or is a
@@ -1675,10 +2015,33 @@
         """
         uri = str(href)
         if self.principalURL() == uri:
-            return True
+            yield True
+            return
         else:
-            return uri in self.groupMembers()
+            d = waitForDeferred(self.expandedGroupMembers())
+            yield d
+            members = d.getResult()
+            member_uris = [member.principalURL() for member in members]
+            yield uri in member_uris
 
+class DAVPrincipalCollectionResource (DAVResource):
+    """
+    WebDAV principal collection resource.  (RFC 3744, section 5.8)
+    """
+    implements(IDAVPrincipalCollectionResource)
+
+    def __init__(self, url, principalCollections=()):
+        """
+        @param url: This resource's URL.
+        """
+        DAVResource.__init__(self, principalCollections=principalCollections)
+
+        assert url.endswith("/"), "Collection URL must end in '/'"
+        self._url = url
+
+    def principalCollectionURL(self):
+        return self._url
+
 class AccessDeniedError(Exception):
     def __init__(self, errors):
         """ 
@@ -1718,6 +2081,37 @@
 davxml.registerElement(TwistedACLInheritable)
 davxml.ACE.allowed_children[(twisted_dav_namespace, "inheritable")] = (0, 1)
 
+class TwistedGETContentMD5 (davxml.WebDAVTextElement):
+    """
+    MD5 hash of the resource content.
+    """
+    namespace = twisted_dav_namespace
+    name = "getcontentmd5"
+
+davxml.registerElement(TwistedGETContentMD5)
+
+"""
+When set on a collection, this property indicates that the collection has a quota limit for
+the size of all resources stored in the collection (and any associate meta-data such as properties).
+The value is a number - the maximum size in bytes allowed.
+"""
+class TwistedQuotaRootProperty (davxml.WebDAVTextElement):
+    namespace = twisted_private_namespace
+    name = "quota-root"
+
+davxml.registerElement(TwistedQuotaRootProperty)
+
+"""
+When set on a collection, this property contains the cached running total of the size of all
+resources stored in the collection (and any associate meta-data such as properties).
+The value is a number - the size in bytes used.
+"""
+class TwistedQuotaUsedProperty (davxml.WebDAVTextElement):
+    namespace = twisted_private_namespace
+    name = "quota-used"
+
+davxml.registerElement(TwistedQuotaUsedProperty)
+
 allACL = davxml.ACL(
     davxml.ACE(
         davxml.Principal(davxml.All()),
