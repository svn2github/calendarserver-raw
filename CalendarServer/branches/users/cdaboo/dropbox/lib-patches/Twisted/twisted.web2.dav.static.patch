Index: twisted/web2/dav/static.py
===================================================================
--- twisted/web2/dav/static.py	(revision 18375)
+++ twisted/web2/dav/static.py	(working copy)
@@ -28,16 +28,16 @@
 
 __all__ = ["DAVFile"]
 
-import os
-
-from twisted.python import log
 from twisted.internet.defer import succeed, deferredGenerator, waitForDeferred
-from twisted.web2.static import File
+from twisted.python import log
+from twisted.web2 import http_headers
 from twisted.web2 import responsecode, dirlist
-from twisted.web2.http import RedirectResponse
 from twisted.web2.dav import davxml
 from twisted.web2.dav.resource import DAVResource, davPrivilegeSet
+from twisted.web2.dav.resource import TwistedGETContentMD5
 from twisted.web2.dav.util import bindMethods
+from twisted.web2.http import RedirectResponse
+from twisted.web2.static import File
 
 try:
     from twisted.web2.dav.xattrprops import xattrPropertyStore as DeadPropertyStore
@@ -75,6 +75,12 @@
     # WebDAV
     ##
 
+    def etag(self):
+        if self.hasDeadProperty(TwistedGETContentMD5):
+            return http_headers.ETag(str(self.readDeadProperty(TwistedGETContentMD5)))
+        else:
+            return super(DAVFile, self).etag()
+
     def davComplianceClasses(self):
         return ("1", "access-control") # Add "2" when we have locking
 
@@ -87,7 +93,6 @@
         """
         See L{IDAVResource.isCollection}.
         """
-        for child in self.listChildren(): return True
         return self.fp.isdir()
 
     ##
@@ -98,6 +103,50 @@
         return succeed(davPrivilegeSet)
 
     ##
+    # Quota
+    ##
+
+    def quotaSize(self, request):
+        """
+        Get the size of this resource.
+        TODO: Take into account size of dead-properties. Does stat
+            include xattrs size?
+
+        @return: an L{Deferred} with a C{int} result containing the size of the resource.
+        """
+        if self.isCollection():
+            def walktree(top):
+                """
+                Recursively descend the directory tree rooted at top,
+                calling the callback function for each regular file
+                
+                @param top: L{FilePath} for the directory to walk.
+                """
+            
+                total = 0
+                for f in top.listdir():
+                    child = top.child(f)
+                    if child.isdir():
+                        # It's a directory, recurse into it
+                        result = waitForDeferred(walktree(child))
+                        yield result
+                        total += result.getResult()
+                    elif child.isfile():
+                        # It's a file, call the callback function
+                        total += child.getsize()
+                    else:
+                        # Unknown file type, print a message
+                        pass
+            
+                yield total
+            
+            walktree = deferredGenerator(walktree)
+    
+            return walktree(self.fp)
+        else:
+            return succeed(self.fp.getsize())
+
+    ##
     # Workarounds for issues with File
     ##
 
@@ -133,11 +182,22 @@
                     # Render from the index file
                     standin = self.createSimilarFile(ifp.path)
                 else:
+                    # Do some optimisation of access control calculation by determining any inherited ACLs outside of
+                    # the child resource loop and supply those to the checkPrivileges on each child.
+                    filteredaces = waitForDeferred(self.inheritedACEsforChildren(request))
+                    yield filteredaces
+                    filteredaces = filteredaces.getResult()
+
                     children = []
 
+                    def _childname(r, u):
+                        u = u.rstrip("/")
+                        children.append(u.split("/")[-1])
+
                     d = self.findChildren('1', request,
-                                          lambda r,u: children.append(os.path.basename(u)),
-                                          (davxml.Read(),))
+                                          _childname,
+                                          (davxml.Read(),),
+                                          inherited_aces=filteredaces)
                     d = waitForDeferred(d)
                     yield d
                     d = d.getResult()
