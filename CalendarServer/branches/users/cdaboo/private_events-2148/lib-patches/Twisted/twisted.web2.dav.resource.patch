Index: twisted/web2/dav/resource.py
===================================================================
--- twisted/web2/dav/resource.py	(revision 19773)
+++ twisted/web2/dav/resource.py	(working copy)
@@ -40,10 +40,18 @@
     "unauthenticatedPrincipal",
 ]
 
+import __builtin__
+if not hasattr(__builtin__, "set"):
+    import sets.Set as set
+if not hasattr(__builtin__, "frozenset"):
+    import sets.ImmutableSet as frozenset
+
 import urllib
 
 from zope.interface import implements
 from twisted.python import log
+from twisted.python.failure import Failure
+from twisted.cred.error import LoginFailed, UnauthorizedLogin
 from twisted.internet.defer import Deferred, maybeDeferred, succeed
 from twisted.internet.defer import waitForDeferred, deferredGenerator
 from twisted.internet import reactor
@@ -52,12 +60,13 @@
 from twisted.web2.http_headers import generateContentType
 from twisted.web2.iweb import IResponse
 from twisted.web2.resource import LeafResource
+from twisted.web2.server import NoURLForResourceError
 from twisted.web2.static import MetaDataMixin, StaticRenderMixin
 from twisted.web2.auth.wrapper import UnauthorizedResponse
 from twisted.web2.dav import davxml
 from twisted.web2.dav.davxml import dav_namespace, lookupElement
 from twisted.web2.dav.davxml import twisted_dav_namespace, twisted_private_namespace
-from twisted.web2.dav.idav import IDAVResource, IDAVPrincipalResource
+from twisted.web2.dav.idav import IDAVResource, IDAVPrincipalResource, IDAVPrincipalCollectionResource
 from twisted.web2.dav.http import NeedPrivilegesResponse
 from twisted.web2.dav.noneprops import NonePropertyStore
 from twisted.web2.dav.util import unimplemented, parentForURL, joinURL
@@ -130,6 +139,8 @@
         (dav_namespace, "acl-restrictions"          ), # RFC 3744, section 5.6
         (dav_namespace, "inherited-acl-set"         ), # RFC 3744, section 5.7
         (dav_namespace, "principal-collection-set"  ), # RFC 3744, section 5.8
+        (dav_namespace, "quota-available-bytes"     ), # RFC 4331, section 3
+        (dav_namespace, "quota-used-bytes"          ), # RFC 4331, section 4
 
         (twisted_dav_namespace, "resource-class"),
     )
@@ -166,6 +177,14 @@
         if qname[0] == twisted_private_namespace:
             return succeed(False)
 
+        # Need to special case the dynamic live properties
+        namespace, name = qname
+        if namespace == dav_namespace:
+            if name in ("quota-available-bytes", "quota-used-bytes"):
+                d = self.hasQuota(request)
+                d.addCallback(lambda result: result)
+                return d
+        
         return succeed(qname in self.liveProperties or self.deadProperties().contains(qname))
 
     def readProperty(self, property, request):
@@ -239,8 +258,10 @@
                     )
 
                 if name == "supported-report-set":
-                    supported = [davxml.SupportedReport(report,) for report in self.supportedReports()]
-                    return davxml.SupportedReportSet(*supported)
+                    return davxml.SupportedReportSet(*[
+                        davxml.SupportedReport(report,)
+                        for report in self.supportedReports()
+                    ])
 
                 if name == "supported-privilege-set":
                     return self.supportedPrivileges(request)
@@ -252,9 +273,10 @@
                     return davxml.InheritedACLSet(*self.inheritedACLSet())
 
                 if name == "principal-collection-set":
-                    d = self.principalCollections(request)
-                    d.addCallback(lambda collections: davxml.PrincipalCollectionSet(*collections))
-                    return d
+                    return davxml.PrincipalCollectionSet(*[
+                        davxml.HRef(principalCollection.principalCollectionURL())
+                        for principalCollection in self.principalCollections()
+                    ])
 
                 def ifAllowed(privileges, callback):
                     def onError(failure):
@@ -286,7 +308,33 @@
                         d.addCallback(gotACL)
                         return d
                     return ifAllowed((davxml.ReadACL(),), callback)
+                    
+                if name == "quota-available-bytes":
+                    def callback(qvalue):
+                        if qvalue is None:
+                            raise HTTPError(StatusResponse(
+                                responsecode.NOT_FOUND,
+                                "Property %s does not exist." % (sname,)
+                            ))
+                        else:
+                            return davxml.QuotaAvailableBytes(str(qvalue[0]))
+                    d = self.quota(request)
+                    d.addCallback(callback)
+                    return d
 
+                if name == "quota-used-bytes":
+                    def callback(qvalue):
+                        if qvalue is None:
+                            raise HTTPError(StatusResponse(
+                                responsecode.NOT_FOUND,
+                                "Property %s does not exist." % (sname,)
+                            ))
+                        else:
+                            return davxml.QuotaUsedBytes(str(qvalue[1]))
+                    d = self.quota(request)
+                    d.addCallback(callback)
+                    return d
+
             elif namespace == twisted_dav_namespace:
                 if name == "resource-class":
                     class ResourceClass (davxml.WebDAVTextElement):
@@ -363,15 +411,28 @@
         """
         See L{IDAVResource.listProperties}.
         """
-        # FIXME: A set would be better here, that that's a python 2.4+ feature.
-        qnames = list(self.liveProperties)
+        qnames = set(self.liveProperties)
 
+        # Add dynamic live properties that exist
+        dynamicLiveProperties = (
+            (dav_namespace, "quota-available-bytes"     ),
+            (dav_namespace, "quota-used-bytes"          ),
+        )
+        for dqname in dynamicLiveProperties:
+            has = waitForDeferred(self.hasProperty(dqname, request))
+            yield has
+            has = has.getResult()
+            if not has:
+                qnames.remove(dqname)
+
         for qname in self.deadProperties().list():
             if (qname not in qnames) and (qname[0] != twisted_private_namespace):
-                qnames.append(qname)
+                qnames.add(qname)
 
-        return succeed(qnames)
+        yield qnames
 
+    listProperties = deferredGenerator(listProperties)
+
     def listAllprop(self, request):
         """
         Some DAV properties should not be returned to a C{DAV:allprop} query.
@@ -465,8 +526,22 @@
             return super(DAVPropertyMixIn, self).displayName()
 
 class DAVResource (DAVPropertyMixIn, StaticRenderMixin):
+    """
+    WebDAV resource.
+    """
     implements(IDAVResource)
 
+    def __init__(self, principalCollections=None):
+        """
+        @param principalCollections: an iterable of L{IDAVPrincipalCollectionResource}s
+            which contain principals to be used in ACLs for this resource.
+        """
+        if principalCollections is not None:
+            self._principalCollections = frozenset([
+                IDAVPrincipalCollectionResource(principalCollection)
+                for principalCollection in principalCollections
+            ])
+
     ##
     # DAV
     ##
@@ -570,19 +645,21 @@
         See L{IDAVResource.authorize}.
         """
         def onError(failure):
-            log.err("Invalid authentication details: %s" % (request,))
-            raise HTTPError(UnauthorizedResponse(
+            failure.trap(UnauthorizedLogin, LoginFailed)
+
+            log.err("Authentication failed: %s" % (failure.value,))
+            return Failure(HTTPError(UnauthorizedResponse(
                 request.credentialFactories,
                 request.remoteAddr
-            ))
+            )))
 
         def onAuth(result):
             def onErrors(failure):
                 failure.trap(AccessDeniedError)
                 
-                # If we were unauthorized to start with (no Authorization header from client) then
+                # If we were unauthenticated to start with (no Authorization header from client) then
                 # we should return an unauthorized response instead to force the client to login if it can
-                if request.user == davxml.Principal(davxml.Unauthenticated()):
+                if request.authnUser == davxml.Principal(davxml.Unauthenticated()):
                     response = UnauthorizedResponse(request.credentialFactories,
                                                     request.remoteAddr)
                 else:
@@ -593,7 +670,7 @@
                 # class is supposed to be a FORBIDDEN status code and
                 # "Authorization will not help" according to RFC2616
                 #
-                raise HTTPError(response)
+                return Failure(HTTPError(response))
 
             d = self.checkPrivileges(request, privileges, recurse)
             d.addErrback(onErrors)
@@ -606,16 +683,21 @@
 
     def authenticate(self, request):
         def loginSuccess(result):
-            request.user = result[1]
-            return request.user
+            """
+            @param result: returned tuple from auth.DAVRealm.requestAvatar.
+            """
+            request.authnUser = result[1]
+            request.authzUser = result[2]
+            return (request.authnUser, request.authzUser,)
 
         if not (
             hasattr(request, 'portal') and 
             hasattr(request, 'credentialFactories') and
             hasattr(request, 'loginInterfaces')
         ):
-            request.user = davxml.Principal(davxml.Unauthenticated())
-            return request.user
+            request.authnUser = davxml.Principal(davxml.Unauthenticated())
+            request.authzUser = davxml.Principal(davxml.Unauthenticated())
+            return (request.authnUser, request.authzUser,)
 
         authHeader = request.headers.getHeader('authorization')
 
@@ -631,9 +713,10 @@
 
                 # Try to match principals in each principal collection on the resource
                 def gotDetails(details):
-                    principal = IDAVPrincipalResource(details[0])
-                    principalURI = details[1]
-                    return PrincipalCredentials(principal, principalURI, creds)
+                    authnPrincipal, authzPrincipal = details
+                    authnPrincipal = IDAVPrincipalResource(authnPrincipal)
+                    authzPrincipal = IDAVPrincipalResource(authzPrincipal)
+                    return PrincipalCredentials(authnPrincipal, authzPrincipal, creds)
 
                 def login(pcreds):
                     d = request.portal.login(pcreds, None, *request.loginInterfaces)
@@ -641,13 +724,15 @@
 
                     return d
 
-                d = self.findPrincipalForAuthID(request, creds.username)
-                d.addCallback(gotDetails).addCallback(login)
+                d = self.principalsForAuthID(request, creds.username)
+                d.addCallback(gotDetails)
+                d.addCallback(login)
 
                 return d
         else:
-            request.user = davxml.Principal(davxml.Unauthenticated())
-            return request.user
+            request.authnUser = davxml.Principal(davxml.Unauthenticated())
+            request.authzUser = davxml.Principal(davxml.Unauthenticated())
+            return (request.authnUser, request.authzUser,)
 
     ##
     # ACL
@@ -656,49 +741,23 @@
     def currentPrincipal(self, request):
         """
         @param request: the request being processed.
-        @return: the current principal, as derived from the given request.
+        @return: the current authorized principal, as derived from the given request.
         """
-        if hasattr(request, "user"):
-            return request.user
+        if hasattr(request, "authzUser"):
+            return request.authzUser
         else:
             return unauthenticatedPrincipal
 
-    def principalCollections(self, request):
+    def principalCollections(self):
         """
         See L{IDAVResource.accessControlList}.
-
-        This implementation tries to read the L{davxml.PrincipalCollectionSet}
-        from the dead property store of this resource and uses that. If not
-        present on this resource, it tries to get it from the parent, unless it
-        is the root or has no parent.
         """
-        try:
-            principalCollections = self.readDeadProperty(davxml.PrincipalCollectionSet).childrenOfType(davxml.HRef)
-        except HTTPError, e:
-            if e.response.code != responsecode.NOT_FOUND:
-                raise
+        if hasattr(self, "_principalCollections"):
+            return self._principalCollections
+        else:
+            return ()
 
-            principalCollections = []
-
-            # Try the parent
-            myURL = request.urlForResource(self)
-            if myURL != "/":
-                parentURL = parentForURL(myURL)
-
-                parent = waitForDeferred(request.locateResource(parentURL))
-                yield parent
-                parent = parent.getResult()
-
-                if parent:
-                    principalCollections = waitForDeferred(parent.principalCollections(request))
-                    yield principalCollections
-                    principalCollections = principalCollections.getResult()
-
-        yield principalCollections
-
-    principalCollections = deferredGenerator(principalCollections)
-
-    def defaultAccessControlList(self):
+    def defaultRootAccessControlList(self):
         """
         @return: the L{davxml.ACL} element containing the default access control
             list for this resource.
@@ -710,6 +769,17 @@
         #
         return readonlyACL
 
+    def defaultAccessControlList(self):
+        """
+        @return: the L{davxml.ACL} element containing the default access control
+            list for this resource.
+        """
+        #
+        # The default behaviour is no ACL; we should inherrit from the parent
+        # collection.
+        #
+        return davxml.ACL()
+
     def setAccessControlList(self, acl):
         """
         See L{IDAVResource.setAccessControlList}.
@@ -1038,9 +1108,9 @@
 
             if myURL == "/":
                 # If we get to the root without any ACLs, then use the default.
+                acl = self.defaultRootAccessControlList()
+            else:
                 acl = self.defaultAccessControlList()
-            else:
-                acl = davxml.ACL()
 
         # Dynamically update privileges for those ace's that are inherited.
         if inheritance:
@@ -1076,7 +1146,7 @@
                                 # Adjust ACE for inherit on this resource
                                 children = list(ace.children)
                                 children.remove(TwistedACLInheritable())
-                                children.append(davxml.Inherited(davxml.HRef.fromString(parentURL)))
+                                children.append(davxml.Inherited(davxml.HRef(parentURL)))
                                 aces.append(davxml.ACE(*children))
             else:
                 aces.extend(inherited_aces)
@@ -1128,7 +1198,7 @@
                 # Adjust ACE for inherit on this resource
                 children = list(ace.children)
                 children.remove(TwistedACLInheritable())
-                children.append(davxml.Inherited(davxml.HRef.fromString(request.urlForResource(self))))
+                children.append(davxml.Inherited(davxml.HRef(request.urlForResource(self))))
                 aces.append(davxml.ACE(*children))
                 
         # Filter out those that do not have a principal match with the current principal
@@ -1152,49 +1222,69 @@
 
         This implementation returns an empty set.
         """
-
         return []
 
-    def findPrincipalForAuthID(self, request, authid):
+    def principalsForAuthID(self, request, authid):
         """
+        Return authentication and authorization prinicipal identifiers for the
+        authentication identifer passed in. In this implementation authn and authz
+        principals are the same.
+
         @param request: the L{IRequest} for the request in progress.
         @param authid: a string containing the
             authentication/authorization identifier for the principal
             to lookup.
-        @return: a deferred tuple of C{(principal, principalURI)}
-            where: C{principal} is the L{Principal} that is found;
-            C{principalURI} is the C{str} URI of the principal. 
+        @return: a deferred tuple of two tuples. Each tuple is
+            C{(principal, principalURI)} where: C{principal} is the L{Principal}
+            that is found; {principalURI} is the C{str} URI of the principal.
+            The first tuple corresponds to authentication identifiers,
+            the second to authorization identifiers.
             It will errback with an HTTPError(responsecode.FORBIDDEN) if
             the principal isn't found.
         """
-        # Try to match principals in each principal collection on the resource
-        collections = waitForDeferred(self.principalCollections(request))
-        yield collections
-        collections = collections.getResult()
+        authnPrincipal = self.findPrincipalForAuthID(authid)
 
-        for collection in collections:
-            principalURI = joinURL(str(collection), authid)
+        if authnPrincipal is None:
+            log.msg("Could not find the principal resource for user id: %s" % (authid,))
+            raise HTTPError(responsecode.FORBIDDEN)
 
-            principal = waitForDeferred(request.locateResource(principalURI))
-            yield principal
-            principal = principal.getResult()
+        d = self.authorizationPrincipal(request, authid, authnPrincipal)
+        d.addCallback(lambda authzPrincipal: (authnPrincipal, authzPrincipal))
+        return d
 
-            if isPrincipalResource(principal):
-                yield (principal, principalURI)
-                return
-        else:
-            principalCollections = waitForDeferred(self.principalCollections(request))
-            yield principalCollections
-            principalCollections = principalCollections.getResult()
+    def findPrincipalForAuthID(self, authid):
+        """
+        Return authentication and authoirization prinicipal identifiers for the
+        authentication identifer passed in. In this implementation authn and authz
+        principals are the same.
 
-            if len(principalCollections) == 0:
-                log.msg("DAV:principal-collection-set property cannot be found on the resource being authorized: %s" % self)
-            else:
-                log.msg("Could not find principal matching user id: %s" % authid)
-            raise HTTPError(responsecode.FORBIDDEN)
+        @param authid: a string containing the
+            authentication/authorization identifier for the principal
+            to lookup.
+        @return: a tuple of C{(principal, principalURI)} where: C{principal} is the L{Principal}
+            that is found; {principalURI} is the C{str} URI of the principal.
+            If not found return None.
+        """
+        for collection in self.principalCollections():
+            principal = collection.principalForUser(authid)
+            if principal is not None:
+                return principal
+        return None
 
-    findPrincipalForAuthID = deferredGenerator(findPrincipalForAuthID)
-
+    def authorizationPrincipal(self, request, authid, authnPrincipal):
+        """
+        Determine the authorization principal for the given request and authentication principal.
+        This implementation simply uses aht authentication principalk as the authoization principal.
+        
+        @param request: the L{IRequest} for the request in progress.
+        @param authid: a string containing the uthentication/authorization identifier
+            for the principal to lookup.
+        @param authnPrincipal: the L{IDAVPrincipal} for the authenticated principal
+         @return: a deferred result C{tuple} of (L{IDAVPrincipal}, C{str}) containing the authorization principal
+            resource and URI respectively.
+        """
+        return succeed(authnPrincipal)
+        
     def samePrincipal(self, principal1, principal2):
         """
         Check whether the two prinicpals are exactly the same in terms of
@@ -1219,7 +1309,6 @@
             return False
                 
     def matchPrincipal(self, principal1, principal2, request):
-
         """
         Check whether the principal1 is a principal in the set defined by
         principal2.
@@ -1244,6 +1333,9 @@
             if isinstance(principal1, davxml.Unauthenticated):
                 yield False
                 return
+            elif isinstance(principal1, davxml.All):
+                yield False
+                return
             else:
                 yield True
                 return
@@ -1271,7 +1363,6 @@
 
         assert principal2 is not None, "principal2 is None"
 
-
         # Compare two HRefs and do group membership test as well
         if principal1 == principal2:
             yield True
@@ -1302,9 +1393,9 @@
         def testGroup(group):
             # Get principal resource for principal2
             if group and isinstance(group, DAVPrincipalResource):
-                members = group.groupMembers()
-                if principal1 in members:
-                    return True
+                for member in group.groupMembers():
+                    if member.principalURL() == principal1:
+                        return True
                 
             return False
 
@@ -1351,11 +1442,16 @@
         @return C{True} if C{href_principal} is valid, C{False} otherwise.
 
         This implementation tests for a href element that corresponds to
-        a principal resource.
+        a principal resource and matches the principal-URL.
         """
-        # Must have the principal resource type
+
+        # Must have the principal resource type and must match the principal-URL
+        
+        def _matchPrincipalURL(resource):
+            return isPrincipalResource(resource) and resource.principalURL() == str(href_principal)
+
         d = request.locateResource(str(href_principal))
-        d.addCallback(isPrincipalResource)
+        d.addCallback(_matchPrincipalURL)
         return d
 
     def resolvePrincipal(self, principal, request):
@@ -1432,7 +1528,7 @@
                 log.err("DAV:self ACE is set on non-principal resource %r" % (self,))
                 yield None
                 return
-            principal = davxml.HRef.fromString(self.principalURL())
+            principal = davxml.HRef(self.principalURL())
 
         if isinstance(principal, davxml.HRef):
             yield principal
@@ -1517,6 +1613,270 @@
         return None
 
     ##
+    # Quota
+    ##
+    
+    """
+    The basic policy here is to define a private 'quota-root' property on a collection.
+    That property will contain the maximum allowed bytes for the collections and all
+    its contents.
+    
+    In order to determine the quota property values on a resource, the server must look
+    for the private property on that resource and any of its parents. If found on a parent,
+    then that parent should be queried for quota information. If not found, no quota
+    exists for the resource.
+    
+    To determine tha actual quota in use we will cache the used byte count on the quota-root
+    collection in another private property. It is the servers responsibility to
+    keep that property up to date by adjusting it after every PUT, DELETE, COPY,
+    MOVE, MKCOL, PROPPATCH, ACL, POST or any other method that may affect the size of
+    stored data. If the private property is not present, the server will fall back to
+    getting the size by iterating over all resources (this is done in static.py).
+    
+    """
+
+    def quota(self, request):
+        """
+        Get current available & used quota values for this resource's quota root
+        collection.
+
+        @return: an L{Defered} with result C{tuple} containing two C{int}'s the first is 
+            quota-available-bytes, the second is quota-used-bytes, or
+            C{None} if quota is not defined on the resource.
+        """
+        
+        # See if already cached
+        if not hasattr(request, "quota"):
+            request.quota = {}
+        if request.quota.has_key(self):
+            yield request.quota[self]
+            return
+
+        # Check this resource first
+        if self.isCollection():
+            qroot = self.quotaRoot(request)
+            if qroot is not None:
+                used = waitForDeferred(self.currentQuotaUse(request))
+                yield used
+                used = used.getResult()
+                available = qroot - used
+                if available < 0:
+                    available = 0
+                request.quota[self] = (available, used)
+                yield request.quota[self]
+                return
+        
+        # Check the next parent
+        url = request.urlForResource(self)
+        if url != "/":
+            parent = waitForDeferred(request.locateResource(parentForURL(url)))
+            yield parent
+            parent = parent.getResult()
+            d = waitForDeferred(parent.quota(request))
+            yield d
+            request.quota[self] = d.getResult()
+        else:
+            request.quota[self] = None
+
+        yield request.quota[self]
+        return
+    
+    quota = deferredGenerator(quota)
+
+    def hasQuota(self, request):
+        """
+        Check whether this resource is undre quota control by checking each parent to see if
+        it has a quota root.
+        
+        @return: C{True} if under quota control, C{False} if not.
+        """
+        
+        # Check this one first
+        if self.hasQuotaRoot(request):
+            yield True
+            return
+        
+        # Look at each parent
+        try:
+            url = request.urlForResource(self)
+            if url != "/":
+                parent = waitForDeferred(request.locateResource(parentForURL(url)))
+                yield parent
+                parent = parent.getResult()
+                d = waitForDeferred(parent.hasQuota(request))
+                yield d
+                yield d.getResult()
+            else:
+                yield False
+        except NoURLForResourceError:
+            yield False
+    
+    hasQuota = deferredGenerator(hasQuota)
+        
+    def hasQuotaRoot(self, request):
+        """
+        @return: a C{True} if this resource has quota root, C{False} otherwise.
+        """
+        return self.hasDeadProperty(TwistedQuotaRootProperty)
+    
+    def quotaRoot(self, request):
+        """
+        @return: a C{int} containing the maximum allowed bytes if this collection
+            is quota-controlled, or C{None} if not quota controlled.
+        """
+        if self.hasDeadProperty(TwistedQuotaRootProperty):
+            return int(str(self.readDeadProperty(TwistedQuotaRootProperty)))
+        else:
+            return None
+    
+    def quotaRootParent(self, request):
+        """
+        Return the next quota root above this resource.
+        
+        @return: L{DAVResource} or C{None}
+        """
+
+        # Check the next parent
+        url = request.urlForResource(self)
+        while (url != "/"):
+            url = parentForURL(url)
+            parent = waitForDeferred(request.locateResource(url))
+            yield parent
+            parent = parent.getResult()
+            if parent.hasQuotaRoot(request):
+                yield parent
+                return
+
+        yield None
+    
+    quotaRootParent = deferredGenerator(quotaRootParent)
+        
+    def setQuotaRoot(self, request, maxsize):
+        """
+        @param maxsize: a C{int} containing the maximum allowed bytes for the contents
+            of this collection, or C{None} tp remove quota restriction.
+        """
+        assert self.isCollection(), "Only collections can have a quota root"
+        assert maxsize is None or isinstance(maxsize, int), "maxsize must be an int or None"
+        
+        if maxsize is not None:
+            self.writeDeadProperty(TwistedQuotaRootProperty(str(maxsize)))
+        else:
+            # Remove both the root and the cached used value
+            self.removeDeadProperty(TwistedQuotaRootProperty)
+            self.removeDeadProperty(TwistedQuotaUsedProperty)
+    
+    def quotaSize(self, request):
+        """
+        Get the size of this resource (if its a collection get total for all children as well).
+        TODO: Take into account size of dead-properties.
+
+        @return: a C{int} containing the size of the resource.
+        """
+        unimplemented(self)
+
+    def checkQuota(self, request, available):
+        """
+        Check to see whether all quota roots have sufficient available bytes.
+        We currently do not use hierarchical quota checks - i.e. only the most
+        immediate quota root parent is checked for quota.
+        
+        @param available: a C{int} containing the additional quota required.
+        @return: C{True} if there is sufficient quota remaining on all quota roots,
+            C{False} otherwise.
+        """
+        
+        quotaroot = self
+        while(quotaroot is not None):
+            # Check quota on this root (if it has one)
+            quota = quotaroot.quotaRoot(request)
+            if quota is not None:
+                if available > quota[0]:
+                    yield False
+                    return
+
+            # Check the next parent with a quota root
+            quotaroot = waitForDeferred(quotaroot.quotaRootParent(request))
+            yield quotaroot
+            quotaroot = quotaroot.getResult()
+
+        yield True
+
+    checkQuota = deferredGenerator(checkQuota)
+
+    def quotaSizeAdjust(self, request, adjust):
+        """
+        Update the quota used value on all quota root parents of this resource.
+
+        @param adjust: a C{int} containing the number of bytes added (positive) or
+            removed (negative) that should be used to adjust the cached total.
+        """
+        
+        # Check this resource first
+        if self.isCollection():
+            if self.hasQuotaRoot(request):
+                d = waitForDeferred(self.updateQuotaUse(request, adjust))
+                yield d
+                d.getResult()
+        
+        # Check the next parent
+        url = request.urlForResource(self)
+        if url != "/":
+            parent = waitForDeferred(request.locateResource(parentForURL(url)))
+            yield parent
+            parent = parent.getResult()
+            d = waitForDeferred(parent.quotaSizeAdjust(request, adjust))
+            yield d
+            d.getResult()
+
+        yield None
+
+    quotaSizeAdjust = deferredGenerator(quotaSizeAdjust)
+
+    def currentQuotaUse(self, request):
+        """
+        Get the cached quota use value, or if not present (or invalid) determine
+        quota use by brute force.
+
+        @return: an L{Deferred} with a C{int} result containing the current used byte if this collection
+            is quota-controlled, or C{None} if not quota controlled.
+        """
+        assert self.isCollection(), "Only collections can have a quota root"
+        assert self.hasQuotaRoot(request), "Quota use only on quota root collection"
+        
+        # Try to get the cached value property
+        if self.hasDeadProperty(TwistedQuotaUsedProperty):
+            return succeed(int(str(self.readDeadProperty(TwistedQuotaUsedProperty))))
+        else:
+            # Do brute force size determination and cache the result in the private property
+            def _defer(result):
+                self.writeDeadProperty(TwistedQuotaUsedProperty(str(result)))
+                return result
+            d = self.quotaSize(request)
+            d.addCallback(_defer)
+            return d
+
+    def updateQuotaUse(self, request, adjust):
+        """
+        Update the quota used value on this resource.
+
+        @param adjust: a C{int} containing the number of bytes added (positive) or
+        removed (negative) that should be used to adjust the cached total.
+        @return: an L{Deferred} with a C{int} result containing the current used byte if this collection
+            is quota-controlled, or C{None} if not quota controlled.
+        """
+        assert self.isCollection(), "Only collections can have a quota root"
+        
+        # Get current value
+        def _defer(size):
+            size += adjust
+            self.writeDeadProperty(TwistedQuotaUsedProperty(str(size)))
+
+        d = self.currentQuotaUse(request)
+        d.addCallback(_defer)
+        return d
+        
+    ##
     # HTTP
     ##
 
@@ -1567,7 +1927,7 @@
     def findChildren(self, depth, request, callback, privileges=None, inherited_aces=None):
         return succeed(None)
 
-class DAVPrincipalResource (DAVLeafResource):
+class DAVPrincipalResource (DAVResource):
     """
     Resource representing a WebDAV principal.  (RFC 3744, section 2)
     """
@@ -1577,7 +1937,7 @@
     # WebDAV
     ##
 
-    liveProperties = DAVLeafResource.liveProperties + (
+    liveProperties = DAVResource.liveProperties + (
         (dav_namespace, "alternate-URI-set"),
         (dav_namespace, "principal-URL"    ),
         (dav_namespace, "group-member-set" ),
@@ -1585,14 +1945,11 @@
     )
 
     def davComplianceClasses(self):
-        return ("1",)
+        return ("1", "access-control",)
 
     def isCollection(self):
         return False
 
-    def findChildren(self, depth, request, callback, privileges=None, inherited_aces=None):
-        return succeed(None)
-
     def readProperty(self, property, request):
         def defer():
             if type(property) is tuple:
@@ -1610,10 +1967,10 @@
                     return davxml.PrincipalURL(davxml.HRef(self.principalURL()))
 
                 if name == "group-member-set":
-                    return davxml.GroupMemberSet(*[davxml.HRef(p) for p in self.groupMembers()])
+                    return davxml.GroupMemberSet(*[davxml.HRef(p.principalURL()) for p in self.groupMembers()])
 
                 if name == "group-membership":
-                    return davxml.GroupMembership(*[davxml.HRef(g) for g in self.groupMemberships()])
+                    return davxml.GroupMembership(*[davxml.HRef(g.principalURL()) for g in self.groupMemberships()])
 
                 if name == "resourcetype":
                     if self.isCollection():
@@ -1677,8 +2034,27 @@
         if self.principalURL() == uri:
             return True
         else:
-            return uri in self.groupMembers()
+            member_uris = [member.principalURL() for member in self.groupMembers()]
+            return uri in member_uris
 
+class DAVPrincipalCollectionResource (DAVResource):
+    """
+    WebDAV principal collection resource.  (RFC 3744, section 5.8)
+    """
+    implements(IDAVPrincipalCollectionResource)
+
+    def __init__(self, url, principalCollections=()):
+        """
+        @param url: This resource's URL.
+        """
+        DAVResource.__init__(self, principalCollections=principalCollections)
+
+        assert url.endswith("/"), "Collection URL must end in '/'"
+        self._url = url
+
+    def principalCollectionURL(self):
+        return self._url
+
 class AccessDeniedError(Exception):
     def __init__(self, errors):
         """ 
@@ -1718,6 +2094,37 @@
 davxml.registerElement(TwistedACLInheritable)
 davxml.ACE.allowed_children[(twisted_dav_namespace, "inheritable")] = (0, 1)
 
+class TwistedGETContentMD5 (davxml.WebDAVTextElement):
+    """
+    MD5 hash of the resource content.
+    """
+    namespace = twisted_dav_namespace
+    name = "getcontentmd5"
+
+davxml.registerElement(TwistedGETContentMD5)
+
+"""
+When set on a collection, this property indicates that the collection has a quota limit for
+the size of all resources stored in the collection (and any associate meta-data such as properties).
+The value is a number - the maximum size in bytes allowed.
+"""
+class TwistedQuotaRootProperty (davxml.WebDAVTextElement):
+    namespace = twisted_private_namespace
+    name = "quota-root"
+
+davxml.registerElement(TwistedQuotaRootProperty)
+
+"""
+When set on a collection, this property contains the cached running total of the size of all
+resources stored in the collection (and any associate meta-data such as properties).
+The value is a number - the size in bytes used.
+"""
+class TwistedQuotaUsedProperty (davxml.WebDAVTextElement):
+    namespace = twisted_private_namespace
+    name = "quota-used"
+
+davxml.registerElement(TwistedQuotaUsedProperty)
+
 allACL = davxml.ACL(
     davxml.ACE(
         davxml.Principal(davxml.All()),
