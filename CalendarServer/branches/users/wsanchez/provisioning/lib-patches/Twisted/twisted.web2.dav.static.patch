Index: twisted/web2/dav/static.py
===================================================================
--- twisted/web2/dav/static.py	(revision 18545)
+++ twisted/web2/dav/static.py	(working copy)
@@ -28,16 +28,16 @@
 
 __all__ = ["DAVFile"]
 
-import os
-
+from twisted.internet.defer import succeed, deferredGenerator, waitForDeferred
 from twisted.python import log
-from twisted.internet.defer import succeed, deferredGenerator, waitForDeferred
-from twisted.web2.static import File
+from twisted.web2 import http_headers
 from twisted.web2 import responsecode, dirlist
-from twisted.web2.http import RedirectResponse
 from twisted.web2.dav import davxml
 from twisted.web2.dav.resource import DAVResource, davPrivilegeSet
+from twisted.web2.dav.resource import TwistedGETContentMD5
 from twisted.web2.dav.util import bindMethods
+from twisted.web2.http import RedirectResponse
+from twisted.web2.static import File
 
 try:
     from twisted.web2.dav.xattrprops import xattrPropertyStore as DeadPropertyStore
@@ -75,6 +75,12 @@
     # WebDAV
     ##
 
+    def etag(self):
+        if self.hasDeadProperty(TwistedGETContentMD5):
+            return http_headers.ETag(str(self.readDeadProperty(TwistedGETContentMD5)))
+        else:
+            return super(DAVFile, self).etag()
+
     def davComplianceClasses(self):
         return ("1", "access-control") # Add "2" when we have locking
 
@@ -87,7 +93,6 @@
         """
         See L{IDAVResource.isCollection}.
         """
-        for child in self.listChildren(): return True
         return self.fp.isdir()
 
     ##
@@ -98,6 +103,50 @@
         return succeed(davPrivilegeSet)
 
     ##
+    # Quota
+    ##
+
+    def quotaSize(self, request):
+        """
+        Get the size of this resource.
+        TODO: Take into account size of dead-properties. Does stat
+            include xattrs size?
+
+        @return: an L{Deferred} with a C{int} result containing the size of the resource.
+        """
+        if self.isCollection():
+            def walktree(top):
+                """
+                Recursively descend the directory tree rooted at top,
+                calling the callback function for each regular file
+                
+                @param top: L{FilePath} for the directory to walk.
+                """
+            
+                total = 0
+                for f in top.listdir():
+                    child = top.child(f)
+                    if child.isdir():
+                        # It's a directory, recurse into it
+                        result = waitForDeferred(walktree(child))
+                        yield result
+                        total += result.getResult()
+                    elif child.isfile():
+                        # It's a file, call the callback function
+                        total += child.getsize()
+                    else:
+                        # Unknown file type, print a message
+                        pass
+            
+                yield total
+            
+            walktree = deferredGenerator(walktree)
+    
+            return walktree(self.fp)
+        else:
+            return succeed(self.fp.getsize())
+
+    ##
     # Workarounds for issues with File
     ##
 
@@ -142,53 +191,50 @@
         directory contents that they have read permissions for.
         """
         if not self.fp.exists():
-            yield responsecode.NOT_FOUND
-            return
+            return responsecode.NOT_FOUND
 
-        if self.fp.isdir():
-            if request.uri[-1] != "/":
-                # Redirect to include trailing '/' in URI
-                yield RedirectResponse(
-                    request.unparseURL(path=request.path+'/'))
-                return
-            else:
-                ifp = self.fp.childSearchPreauth(*self.indexNames)
-                if ifp:
-                    # Render from the index file
-                    standin = self.createSimilarFile(ifp.path)
-                else:
-                    filtered_aces = waitForDeferred(self.inheritedACEsforChildren(request))
-                    yield filtered_aces
-                    filtered_aces = filtered_aces.getResult()
+        if not self.fp.isdir():
+            # Do regular resource behavior from superclass
+            return super(DAVFile, self).render(request)
 
-                    children = []
+        #
+        # Do custom rendering of directory so that we can enforce ACLs.
+        #
 
-                    def found(request, uri):
-                        children.append(uri.split("/")[-1].rstrip("/"))
+        if request.uri[-1] != "/":
+            # Redirect to include trailing '/' in URI
+            return RedirectResponse(request.unparseURL(path=request.path+'/'))
 
-                    x = waitForDeferred(
-                        self.findChildren("1", request, found, (davxml.Read(),),
-                                          inherited_aces=filtered_aces)
-                    )
-                    yield x
-                    x = x.getResult()
+        # Render from the index file, if we have one
+        index_fp = self.fp.childSearchPreauth(*self.indexNames)
+        if index_fp:
+            return self.createSimilarFile(index_fp.path).render(request)
 
-                    # Render from a DirectoryLister
-                    standin = dirlist.DirectoryLister(
-                        self.fp.path,
-                        children,
-                        self.contentTypes,
-                        self.contentEncodings,
-                        self.defaultType
-                    )
-                yield standin.render(request)
-                return
+        # Render from a DirectoryLister
+        def findChildren(filtered_aces):
+            children = []
 
-        # Do regular resource behavior from superclass
-        yield super(DAVFile, self).render(request)
-    
-    render = deferredGenerator(render)
+            def found(request, uri):
+                children.append(uri.rstrip("/").split("/")[-1])
 
+            d = self.findChildren("1", request, found,
+                                  (davxml.Read(),), inherited_aces=filtered_aces)
+            d.addCallback(render, children)
+            return d
+
+        def render(_, children):
+            return dirlist.DirectoryLister(
+                self.fp.path,
+                children,
+                self.contentTypes,
+                self.contentEncodings,
+                self.defaultType
+            ).render(request)
+
+        d = self.inheritedACEsforChildren(request)
+        d.addCallback(findChildren)
+        return d
+
 #
 # Attach method handlers to DAVFile
 #
