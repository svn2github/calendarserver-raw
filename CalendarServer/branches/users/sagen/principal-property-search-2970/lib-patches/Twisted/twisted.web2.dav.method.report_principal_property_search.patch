Index: twisted/web2/dav/method/report_principal_property_search.py
===================================================================
--- twisted/web2/dav/method/report_principal_property_search.py	(revision 19773)
+++ twisted/web2/dav/method/report_principal_property_search.py	(working copy)
@@ -46,17 +46,23 @@
     Generate a principal-property-search REPORT. (RFC 3744, section 9.4)
     """
 
+
     # Verify root element
     if not isinstance(principal_property_search, davxml.PrincipalPropertySearch):
         raise ValueError("%s expected as root element, not %s."
                          % (davxml.PrincipalPropertySearch.sname(), principal_property_search.sname()))
 
+    # Should we AND (the default) or OR (if test="anyof")?
+    testMode = principal_property_search.attributes.get("test", "allof")
+    if testMode not in ("allof", "anyof"):
+        raise ValueError("Unknown value for test attribute: %s" % (testMode,))
+
     # Only handle Depth: 0
     depth = request.headers.getHeader("depth", "0")
     if depth != "0":
         log.err("Error in prinicpal-property-search REPORT, Depth set to %s" % (depth,))
         raise HTTPError(StatusResponse(responsecode.BAD_REQUEST, "Depth %s not allowed" % (depth,)))
-    
+
     # Get a single DAV:prop element from the REPORT request body
     propertiesForResource = None
     propElement = None
@@ -93,31 +99,53 @@
         else:
             return False
         
-    def propertySearch(resource, request):
+    def propertySearch(resource, request, testMode):
         """
         Test the resource to see if it contains properties matching the
         property-search specification in this report.
         @param resource: the L{DAVFile} for the resource to test.
         @param request:  the current request.
+        @param testMode:  "allof" (AND operation) or "anyof" (OR operation)
         @return:         True if the resource has matching properties, False otherwise.
         """
-        for props, match in propertySearches:
-            # Test each property
-            for prop in props:
-                try:
-                    propvalue = waitForDeferred(resource.readProperty(prop.qname(), request))
-                    yield propvalue
-                    propvalue = propvalue.getResult()
-                    if propvalue and not nodeMatch(propvalue, match):
+
+        if testMode == "allof": # "AND"
+            for props, match in propertySearches:
+                # Test each property
+                for prop in props:
+                    try:
+                        propvalue = waitForDeferred(resource.readProperty(prop.qname(), request))
+                        yield propvalue
+                        propvalue = propvalue.getResult()
+                        if propvalue:
+                            if not nodeMatch(propvalue, match):
+                                yield False
+                                return
+                    except HTTPError:
+                        # No property => no match
                         yield False
                         return
-                except HTTPError:
-                    # No property => no match
-                    yield False
-                    return
-        
-        yield True
+            # we hit on every property
+            yield True
 
+        else: # "OR"
+            for props, match in propertySearches:
+                # Test each property
+                for prop in props:
+                    try:
+                        propvalue = waitForDeferred(resource.readProperty(prop.qname(), request))
+                        yield propvalue
+                        propvalue = propvalue.getResult()
+                        if propvalue:
+                            if nodeMatch(propvalue, match):
+                                yield True
+                                return
+                    except HTTPError:
+                        # No property
+                        pass
+            # we didn't hit any
+            yield False
+
     propertySearch = deferredGenerator(propertySearch)
 
     # Run report
@@ -127,13 +155,8 @@
         matchcount = 0
 
         if applyTo:
-            # Get the principal collection set
-            pset = waitForDeferred(self.principalCollections(request))
-            yield pset
-            pset = pset.getResult()
-
-            for phref in pset:
-                uri = str(phref)
+            for principalCollection in self.principalCollections():
+                uri = principalCollection.principalCollectionURL()
                 resource = waitForDeferred(request.locateResource(uri))
                 yield resource
                 resource = resource.getResult()
@@ -142,42 +165,67 @@
         else:
             resources.append((self, request.uri))
 
-        # Loop over all collections and principal resources within
-        for resource, ruri in resources:
+        if True:
 
-            # Do some optimisation of access control calculation by determining any inherited ACLs outside of
-            # the child resource loop and supply those to the checkPrivileges on each child.
-            filteredaces = waitForDeferred(resource.inheritedACEsforChildren(request))
-            yield filteredaces
-            filteredaces = filteredaces.getResult()
+            for record in self.directory.recordsStartingWith("mor"):
+                resource = self.principalForRecord(record)
+                url = resource.url()
 
-            children = []
-            d = waitForDeferred(resource.findChildren("infinity", request, lambda x, y: children.append((x,y)),
-                                                      privileges=(davxml.Read(),), inherited_aces=filteredaces))
-            yield d
-            d.getResult()
+                # Check size of results is within limit
+                matchcount += 1
+                if matchcount > max_number_of_matches:
+                    raise NumberOfMatchesWithinLimits
 
-            for child, uri in children:
-                if isPrincipalResource(child):
-                    d = waitForDeferred(propertySearch(child, request))
-                    yield d
-                    d = d.getResult()
-                    if d:
-                        # Check size of results is within limit
-                        matchcount += 1
-                        if matchcount > max_number_of_matches:
-                            raise NumberOfMatchesWithinLimits
-    
-                        d = waitForDeferred(prop_common.responseForHref(
-                            request,
-                            responses,
-                            davxml.HRef.fromString(uri),
-                            child,
-                            propertiesForResource,
-                            propElement
-                        ))
+                d = waitForDeferred(prop_common.responseForHref(
+                    request,
+                    responses,
+                    davxml.HRef.fromString(url),
+                    resource,
+                    propertiesForResource,
+                    propElement
+                ))
+                yield d
+                d.getResult()
+
+        else:
+
+            # Loop over all collections and principal resources within
+            for resource, ruri in resources:
+
+                # Do some optimisation of access control calculation by determining any inherited ACLs outside of
+                # the child resource loop and supply those to the checkPrivileges on each child.
+                filteredaces = waitForDeferred(resource.inheritedACEsforChildren(request))
+                yield filteredaces
+                filteredaces = filteredaces.getResult()
+
+                children = []
+                # d = waitForDeferred(resource.findChildren("infinity", request, lambda x, y: children.append((x,y)),
+                d = waitForDeferred(resource.findChildren("1", request, lambda x, y: children.append((x,y)),
+                                                          privileges=(davxml.Read(),), inherited_aces=filteredaces))
+                yield d
+                d.getResult()
+
+                for child, uri in children:
+                    if isPrincipalResource(child):
+                        d = waitForDeferred(propertySearch(child, request, testMode))
                         yield d
-                        d.getResult()
+                        d = d.getResult()
+                        if d:
+                            # Check size of results is within limit
+                            matchcount += 1
+                            if matchcount > max_number_of_matches:
+                                raise NumberOfMatchesWithinLimits
+        
+                            d = waitForDeferred(prop_common.responseForHref(
+                                request,
+                                responses,
+                                davxml.HRef.fromString(uri),
+                                child,
+                                propertiesForResource,
+                                propElement
+                            ))
+                            yield d
+                            d.getResult()
 
     except NumberOfMatchesWithinLimits:
         log.err("Too many matching components in prinicpal-property-search report")
