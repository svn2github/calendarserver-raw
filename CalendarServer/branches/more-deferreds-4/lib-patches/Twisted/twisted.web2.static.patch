Index: twisted/web2/static.py
===================================================================
--- twisted/web2/static.py	(revision 26969)
+++ twisted/web2/static.py	(working copy)
@@ -7,7 +7,7 @@
 """
 
 # System Imports
-import os, time, stat
+import os, time
 import tempfile
 
 # Sibling Imports
@@ -16,7 +16,7 @@
 
 # Twisted Imports
 from twisted.python import filepath
-from twisted.internet.defer import maybeDeferred
+from twisted.internet.defer import maybeDeferred, succeed, deferredGenerator, waitForDeferred
 from zope.interface import implements
 
 class MetaDataMixin(object):
@@ -28,7 +28,7 @@
         """
         @return: The current etag for the resource if available, None otherwise.
         """
-        return None
+        return succeed(None)
 
     def lastModified(self):
         """
@@ -64,7 +64,7 @@
         """
         @return: The display name of the resource if available, None otherwise.
         """
-        return None
+        return succeed(None)
 
     def exists(self):
         """
@@ -76,18 +76,26 @@
     def checkPreconditions(self, request):
         # This code replaces the code in resource.RenderMixin
         if request.method not in ("GET", "HEAD"):
+            etag = waitForDeferred(self.etag())
+            yield etag
+            etag = etag.getResult()
             http.checkPreconditions(
                 request,
                 entityExists = self.exists(),
-                etag = self.etag(),
+                etag = etag,
                 lastModified = self.lastModified(),
             )
 
         # Check per-method preconditions
         method = getattr(self, "preconditions_" + request.method, None)
         if method:
-            return method(request)
+            result = waitForDeferred(method(request))
+            yield result
+            result = result.getResult()
+            yield result
 
+    checkPreconditions = deferredGenerator(checkPreconditions)
+
     def renderHTTP(self, request):
         """
         See L{resource.RenderMixIn.renderHTTP}.
@@ -100,16 +108,23 @@
 
             # Don't provide additional resource information to error responses
             if response.code < 400:
-                # Content-* headers refer to the response content, not
-                # (necessarily) to the resource content, so they depend on the
-                # request method, and therefore can't be set here.
-                for (header, value) in (
-                    ("etag", self.etag()),
-                    ("last-modified", self.lastModified()),
-                ):
-                    if value is not None:
-                        response.headers.setHeader(header, value)
+                d = self.etag()
+                def _gotEtag(etag):
+                    # Content-* headers refer to the response content, not
+                    # (necessarily) to the resource content, so they depend on the
+                    # request method, and therefore can't be set here.
+                    for (header, value) in (
+                        ("etag", etag),
+                        ("last-modified", self.lastModified()),
+                    ):
+                        if value is not None:
+                            response.headers.setHeader(header, value)
 
+                    return response
+
+                d.addCallback(_gotEtag)
+                return d
+
             return response
 
         def onError(f):
@@ -132,8 +147,8 @@
 
     def etag(self):
         lastModified = self.lastModified()
-        return http_headers.ETag("%X-%X" % (lastModified, hash(self.data)),
-                                 weak=(time.time() - lastModified <= 1))
+        return succeed(http_headers.ETag("%X-%X" % (lastModified, hash(self.data)),
+                                 weak=(time.time() - lastModified <= 1)))
 
     def lastModified(self):
         return self.creationDate()
@@ -213,13 +228,19 @@
         if indexNames is not None:
             self.indexNames = indexNames
 
+    def comparePath(self, path):
+        if isinstance(path, filepath.FilePath):
+            return path.path == self.fp.path
+        else:
+            return path == self.fp.path
+
     def exists(self):
         return self.fp.exists()
 
     def etag(self):
-        if not self.fp.exists(): return None
+        if not self.fp.exists(): return succeed(None)
 
-        st = self.fp.statinfo
+        st = self.fp.getstatinfo()
 
         #
         # Mark ETag as weak if it was modified more recently than we can
@@ -228,10 +249,10 @@
         #
         weak = (time.time() - st.st_mtime <= 1)
 
-        return http_headers.ETag(
+        return succeed(http_headers.ETag(
             "%X-%X-%X" % (st.st_ino, st.st_size, st.st_mtime),
             weak=weak
-        )
+        ))
 
     def lastModified(self):
         if self.fp.exists():
@@ -279,9 +300,9 @@
 
     def displayName(self):
         if self.fp.exists():
-            return self.fp.basename()
+            return succeed(self.fp.basename())
         else:
-            return None
+            return succeed(None)
 
     def ignoreExt(self, ext):
         """Ignore the given extension.
@@ -291,12 +312,13 @@
         self.ignoredExts.append(ext)
 
     def directoryListing(self):
-        return dirlist.DirectoryLister(self.fp.path,
-                                       self.listChildren(),
-                                       self.contentTypes,
-                                       self.contentEncodings,
-                                       self.defaultType)
-
+        return self.listChildren().addCallback(lambda children: dirlist.DirectoryLister(
+                self.fp.path,
+                children,
+                self.contentTypes,
+                self.contentEncodings,
+                self.defaultType))
+                                        
     def putChild(self, name, child):
         """
         Register a child with the given name with this resource.
@@ -311,16 +333,19 @@
         @return: the child of this resource with the given name.
         """
         if name == "":
-            return self
+            return succeed(self)
 
         child = self.putChildren.get(name, None)
-        if child: return child
+        if child: return succeed(child)
 
         child_fp = self.fp.child(name)
+        if hasattr(self, "knownChildren"):
+            if name in self.knownChildren:
+                child_fp.existsCached = True
         if child_fp.exists():
-            return self.createSimilarFile(child_fp.path)
+            return self.createSimilarFile(child_fp)
         else:
-            return None
+            return succeed(None)
 
     def listChildren(self):
         """
@@ -329,21 +354,28 @@
         children = self.putChildren.keys()
         if self.fp.isdir():
             children += [c for c in self.fp.listdir() if c not in children]
-        return children
+            self.knownChildren = set(children)
+        return succeed(children)
 
     def locateChild(self, req, segments):
         """
         See L{IResource}C{.locateChild}.
         """
         # If getChild() finds a child resource, return it
-        child = self.getChild(segments[0])
-        if child is not None: return (child, segments[1:])
+        child = waitForDeferred(self.getChild(segments[0]))
+        yield child
+        child = child.getResult()
+        if child is not None:
+            yield (child, segments[1:])
+            return
 
         # If we're not backed by a directory, we have no children.
         # But check for existance first; we might be a collection resource
         # that the request wants created.
         self.fp.restat(False)
-        if self.fp.exists() and not self.fp.isdir(): return (None, ())
+        if self.fp.exists() and not self.fp.isdir():
+            yield (None, ())
+            return
 
         # OK, we need to return a child corresponding to the first segment
         path = segments[0]
@@ -352,26 +384,31 @@
             fpath = self.fp.child(path)
         else:
             # Request is for a directory (collection) resource
-            return (self, server.StopTraversal)
+            yield (self, server.StopTraversal)
+            return
 
         # Don't run processors on directories - if someone wants their own
         # customized directory rendering, subclass File instead.
         if fpath.isfile():
             processor = self.processors.get(fpath.splitext()[1].lower())
             if processor:
-                return (
-                    processor(fpath.path),
-                    segments[1:])
+                yield (processor(fpath.path), segments[1:])
+                return
 
         elif not fpath.exists():
             sibling_fpath = fpath.siblingExtensionSearch(*self.ignoredExts)
             if sibling_fpath is not None:
                 fpath = sibling_fpath
 
-        return self.createSimilarFile(fpath.path), segments[1:]
+        result = waitForDeferred(self.createSimilarFile(fpath.path), segments[1:])
+        yield result
+        result = result.getResult()
+        yield result
 
+    locateChild = deferredGenerator(locateChild)
+
     def renderHTTP(self, req):
-        self.fp.restat(False)
+        self.fp.changed()
         return super(File, self).renderHTTP(req)
 
     def render(self, req):
@@ -387,17 +424,18 @@
                 ifp = self.fp.childSearchPreauth(*self.indexNames)
                 if ifp:
                     # Render from the index file
-                    standin = self.createSimilarFile(ifp.path)
+                    # MOR: What is going on here?
+                    standin = self.createSimilarFile(ifp.path).render(req)
                 else:
                     # Render from a DirectoryLister
-                    standin = dirlist.DirectoryLister(
-                        self.fp.path,
-                        self.listChildren(),
-                        self.contentTypes,
-                        self.contentEncodings,
-                        self.defaultType
-                    )
-                return standin.render(req)
+                    return self.listChildren().addCallback(
+                         lambda children: dirlist.DirectoryLister(
+                          self.fp.path,
+                          children,
+                          self.contentTypes,
+                          self.contentEncodings,
+                          self.defaultType
+                         ).render(req))
 
         try:
             f = self.fp.open()
@@ -423,8 +461,8 @@
         return response
 
     def createSimilarFile(self, path):
-        return self.__class__(path, self.defaultType, self.ignoredExts,
-                              self.processors, self.indexNames[:])
+        return succeed(self.__class__(path, self.defaultType, self.ignoredExts,
+                              self.processors, self.indexNames[:]))
 
 
 class FileSaver(resource.PostableResource):
